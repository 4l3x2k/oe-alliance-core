diff -ur linux-2.6.18.x86_64~/arch/mips/kernel/scall32-o32.S linux-2.6.18.x86_64/arch/mips/kernel/scall32-o32.S
--- linux-2.6.18.x86_64~/arch/mips/kernel/scall32-o32.S	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/arch/mips/kernel/scall32-o32.S	2010-06-23 21:02:38.000000000 +0900
@@ -662,6 +662,14 @@
 	sys	sys_tee			4
 	sys	sys_vmsplice		4
 	sys	sys_move_pages		6
+	sys	sys_ni_syscall		0
+	sys	sys_ni_syscall		0	/* 4310 */
+	sys	sys_ni_syscall		0
+	sys	sys_ni_syscall		0
+	sys	sys_ni_syscall		0
+	sys	sys_ni_syscall		0
+	sys	sys_ni_syscall		0	/* 4315 */
+	sys	sys_utimensat		4	/* 4316 */
 	.endm
 
 	/* We pre-compute the number of _instruction_ bytes needed to
diff -ur linux-2.6.18.x86_64~/arch/mips/kernel/scall64-64.S linux-2.6.18.x86_64/arch/mips/kernel/scall64-64.S
--- linux-2.6.18.x86_64~/arch/mips/kernel/scall64-64.S	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/arch/mips/kernel/scall64-64.S	2010-06-23 21:02:38.000000000 +0900
@@ -466,3 +466,11 @@
 	PTR	sys_tee				/* 5265 */
 	PTR	sys_vmsplice
 	PTR	sys_move_pages
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall			/* 5270 */
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_utimensat 			/* 5275 */
diff -ur linux-2.6.18.x86_64~/arch/mips/kernel/scall64-n32.S linux-2.6.18.x86_64/arch/mips/kernel/scall64-n32.S
--- linux-2.6.18.x86_64~/arch/mips/kernel/scall64-n32.S	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/arch/mips/kernel/scall64-n32.S	2010-06-23 21:02:38.000000000 +0900
@@ -390,5 +390,14 @@
 	PTR	sys_splice
 	PTR	sys_sync_file_range
 	PTR	sys_tee
-	PTR	sys_vmsplice			/* 6271 */
+	PTR	sys_vmsplice			/* 6270 */
 	PTR	sys_move_pages
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall			/* 6275 */
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_utimensat			/* 6279 */
+
diff -ur linux-2.6.18.x86_64~/arch/mips/kernel/scall64-o32.S linux-2.6.18.x86_64/arch/mips/kernel/scall64-o32.S
--- linux-2.6.18.x86_64~/arch/mips/kernel/scall64-o32.S	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/arch/mips/kernel/scall64-o32.S	2010-06-23 21:02:38.000000000 +0900
@@ -514,4 +514,12 @@
 	PTR	sys_tee
 	PTR	sys_vmsplice
 	PTR	compat_sys_move_pages
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall			/* 4310 */
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall
+	PTR	sys_ni_syscall			/* 4315 */
+	PTR	sys_utimensat			/* 4316 */
 	.size	sys_call_table,.-sys_call_table
diff -ur linux-2.6.18.x86_64~/fs/compat.c linux-2.6.18.x86_64/fs/compat.c
--- linux-2.6.18.x86_64~/fs/compat.c	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/fs/compat.c	2010-06-23 21:02:38.000000000 +0900
@@ -75,30 +75,51 @@
  */
 asmlinkage long compat_sys_utime(char __user *filename, struct compat_utimbuf __user *t)
 {
-	struct timeval tv[2];
+	struct timespec tv[2];
 
 	if (t) {
 		if (get_user(tv[0].tv_sec, &t->actime) ||
 		    get_user(tv[1].tv_sec, &t->modtime))
 			return -EFAULT;
-		tv[0].tv_usec = 0;
-		tv[1].tv_usec = 0;
+		tv[0].tv_nsec = 0;
+		tv[1].tv_nsec = 0;
 	}
-	return do_utimes(AT_FDCWD, filename, t ? tv : NULL);
+	return do_utimes(AT_FDCWD, filename, t ? tv : NULL, 0);
 }
 
+asmlinkage long compat_sys_utimensat(unsigned int dfd, char __user *filename, struct compat_timespec __user *t, int flags)
+{
+	struct timespec tv[2];
+
+	if  (t) {
+		if (get_compat_timespec(&tv[0], &t[0]) ||
+		    get_compat_timespec(&tv[1], &t[1]))
+			return -EFAULT;
+
+		if (tv[0].tv_nsec == UTIME_OMIT && tv[1].tv_nsec == UTIME_OMIT)
+			return 0;
+	}
+	return do_utimes(dfd, filename, t ? tv : NULL, flags);
+}
+
+
 asmlinkage long compat_sys_futimesat(unsigned int dfd, char __user *filename, struct compat_timeval __user *t)
 {
-	struct timeval tv[2];
+	struct timespec tv[2];
 
-	if (t) {
+	if  (t) {
 		if (get_user(tv[0].tv_sec, &t[0].tv_sec) ||
-		    get_user(tv[0].tv_usec, &t[0].tv_usec) ||
+		    get_user(tv[0].tv_nsec, &t[0].tv_usec) ||
 		    get_user(tv[1].tv_sec, &t[1].tv_sec) ||
-		    get_user(tv[1].tv_usec, &t[1].tv_usec))
+		    get_user(tv[1].tv_nsec, &t[1].tv_usec))
 			return -EFAULT;
+		if (tv[0].tv_nsec >= 1000000 || tv[0].tv_nsec < 0 ||
+		    tv[1].tv_nsec >= 1000000 || tv[1].tv_nsec < 0)
+			return -EINVAL;
+		tv[0].tv_nsec *= 1000;
+		tv[1].tv_nsec *= 1000;
 	}
-	return do_utimes(dfd, filename, t ? tv : NULL);
+	return do_utimes(dfd, filename, t ? tv : NULL, 0);
 }
 
 asmlinkage long compat_sys_utimes(char __user *filename, struct compat_timeval __user *t)
--- linux-2.6.18.x86_64~/fs/open.c	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/fs/open.c	2010-06-24 13:05:36.000000000 +0900
@@ -496,18 +496,39 @@
  * must be owner or have write permission.
  * Else, update from *times, must be owner or super user.
  */
-long do_utimes(int dfd, char __user *filename, struct timeval *times)
+long do_utimes(int dfd, char __user *filename, struct timespec *times, int flags)
 {
-	int error;
+	int error = -EINVAL;
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
+	struct dentry *dentry;
+	struct file *f = NULL;
 
-	error = __user_walk_fd(dfd, filename, LOOKUP_FOLLOW, &nd);
-
-	if (error)
+	if (flags & ~AT_SYMLINK_NOFOLLOW)
 		goto out;
-	inode = nd.dentry->d_inode;
+
+	if (filename == NULL && dfd != AT_FDCWD) {
+		if (flags & AT_SYMLINK_NOFOLLOW)
+			goto out;
+
+		f = fget(dfd);
+		error = -EBADF;
+		if (!f)
+			goto out;
+
+		dentry = f->f_dentry;
+	} else {
+		error = __user_walk_fd(dfd, filename, LOOKUP_FOLLOW, &nd);
+		if (error)
+			goto out;
+		dentry = nd.dentry;
+	}
+	inode = dentry->d_inode;
+
+	if (times && times[0].tv_nsec == UTIME_NOW &&
+		     times[1].tv_nsec == UTIME_NOW)
+		times = NULL;
 
 	error = -EROFS;
 	if (IS_RDONLY(inode))
@@ -520,36 +541,97 @@
                 if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
                         goto dput_and_out;
 
-		newattrs.ia_atime.tv_sec = times[0].tv_sec;
-		newattrs.ia_atime.tv_nsec = times[0].tv_usec * 1000;
-		newattrs.ia_mtime.tv_sec = times[1].tv_sec;
-		newattrs.ia_mtime.tv_nsec = times[1].tv_usec * 1000;
-		newattrs.ia_valid |= ATTR_ATIME_SET | ATTR_MTIME_SET;
+		if (times[0].tv_nsec == UTIME_OMIT)
+			newattrs.ia_valid &= ~ATTR_ATIME;
+		else if (times[0].tv_nsec != UTIME_NOW) {
+			newattrs.ia_atime.tv_sec = times[0].tv_sec;
+			newattrs.ia_atime.tv_nsec = times[0].tv_nsec;
+			newattrs.ia_valid |= ATTR_ATIME_SET;
+		}
+
+		if (times[1].tv_nsec == UTIME_OMIT)
+			newattrs.ia_valid &= ~ATTR_MTIME;
+		else if (times[1].tv_nsec != UTIME_NOW) {
+			newattrs.ia_mtime.tv_sec = times[1].tv_sec;
+			newattrs.ia_mtime.tv_nsec = times[1].tv_nsec;
+			newattrs.ia_valid |= ATTR_MTIME_SET;
+		}
+		/*
+		 * Tell inode_change_ok(), that this is an explicit time
+		 * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET
+		 * were used.
+		 */
+		newattrs.ia_valid |= ATTR_TIMES_SET;
 	} else {
 		error = -EACCES;
                 if (IS_IMMUTABLE(inode))
                         goto dput_and_out;
 
-		if (current->fsuid != inode->i_uid &&
-		    (error = vfs_permission(&nd, MAY_WRITE)) != 0)
-			goto dput_and_out;
+		if (current->fsuid != inode->i_uid) {
+			if (f) {
+				if (!(f->f_mode & FMODE_WRITE))
+					goto dput_and_out;
+			} else {
+				if ((error = vfs_permission(&nd, MAY_WRITE)) != 0)
+					goto dput_and_out;
+			}
+		}
 	}
 	mutex_lock(&inode->i_mutex);
-	error = notify_change(nd.dentry, &newattrs);
+	error = notify_change(dentry, &newattrs);
 	mutex_unlock(&inode->i_mutex);
 dput_and_out:
-	path_release(&nd);
+	if (f)
+		fput(f);
+	else
+		path_release(&nd);
 out:
 	return error;
 }
 
+asmlinkage long sys_utimensat(int dfd, char __user *filename,
+		struct timespec __user *utimes, int flags)
+{
+	struct timespec tstimes[2];
+
+	if (utimes) {
+		if (copy_from_user(&tstimes, utimes, sizeof(tstimes)))
+			return -EFAULT;
+
+		/* Nothing to do, we must not even check the path.  */
+		if (tstimes[0].tv_nsec == UTIME_OMIT &&
+		    tstimes[1].tv_nsec == UTIME_OMIT)
+			return 0;
+	}
+
+	return do_utimes(dfd, filename, utimes ? tstimes : NULL, flags);
+}
+
 asmlinkage long sys_futimesat(int dfd, char __user *filename, struct timeval __user *utimes)
 {
 	struct timeval times[2];
+	struct timespec tstimes[2];
+
+	if (utimes) {
+		if (copy_from_user(&times, utimes, sizeof(times)))
+			return -EFAULT;
+
+		/* This test is needed to catch all invalid values.  If we
+		   would test only in do_utimes we would miss those invalid
+		   values truncated by the multiplication with 1000.  Note
+		   that we also catch UTIME_{NOW,OMIT} here which are only
+		   valid for utimensat.  */
+		if (times[0].tv_usec >= 1000000 || times[0].tv_usec < 0 ||
+		    times[1].tv_usec >= 1000000 || times[1].tv_usec < 0)
+			return -EINVAL;
+
+		tstimes[0].tv_sec = times[0].tv_sec;
+		tstimes[0].tv_nsec = 1000 * times[0].tv_usec;
+		tstimes[1].tv_sec = times[1].tv_sec;
+		tstimes[1].tv_nsec = 1000 * times[1].tv_usec;
+	}
 
-	if (utimes && copy_from_user(&times, utimes, sizeof(times)))
-		return -EFAULT;
-	return do_utimes(dfd, filename, utimes ? times : NULL);
+	return do_utimes(dfd, filename, utimes ? tstimes : NULL, 0);
 }
 
 asmlinkage long sys_utimes(char __user *filename, struct timeval __user *utimes)
diff -ur linux-2.6.18.x86_64~/include/asm-mips/unistd.h linux-2.6.18.x86_64/include/asm-mips/unistd.h
--- linux-2.6.18.x86_64~/include/asm-mips/unistd.h	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/include/asm-mips/unistd.h	2010-06-23 21:02:39.000000000 +0900
@@ -329,11 +329,11 @@
 #define __NR_tee			(__NR_Linux + 306)
 #define __NR_vmsplice			(__NR_Linux + 307)
 #define __NR_move_pages			(__NR_Linux + 308)
-
+#define __NR_utimensat			(__NR_Linux + 316)
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
-#define __NR_Linux_syscalls		308
+#define __NR_Linux_syscalls		316
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
 
@@ -614,11 +614,12 @@
 #define __NR_tee			(__NR_Linux + 265)
 #define __NR_vmsplice			(__NR_Linux + 266)
 #define __NR_move_pages			(__NR_Linux + 267)
+#define __NR_utimensat			(__NR_Linux + 275)
 
 /*
  * Offset of the last Linux 64-bit flavoured syscall
  */
-#define __NR_Linux_syscalls		267
+#define __NR_Linux_syscalls		275
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI64 */
 
@@ -903,11 +904,12 @@
 #define __NR_tee			(__NR_Linux + 269)
 #define __NR_vmsplice			(__NR_Linux + 270)
 #define __NR_move_pages			(__NR_Linux + 271)
+#define __NR_utimensat			(__NR_Linux + 279)
 
 /*
  * Offset of the last N32 flavoured syscall
  */
-#define __NR_Linux_syscalls		271
+#define __NR_Linux_syscalls		279
 
 #endif /* _MIPS_SIM == _MIPS_SIM_NABI32 */
 
diff -ur linux-2.6.18.x86_64~/include/linux/fs.h linux-2.6.18.x86_64/include/linux/fs.h
--- linux-2.6.18.x86_64~/include/linux/fs.h	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/include/linux/fs.h	2010-06-23 21:02:39.000000000 +0900
@@ -342,6 +342,9 @@
 #define ATTR_KILL_SUID	2048
 #define ATTR_KILL_SGID	4096
 #define ATTR_FILE	8192
+#define ATTR_KILL_PRIV  16384
+#define ATTR_OPEN       32768 /* Truncating from open(O_TRUNC) */
+#define ATTR_TIMES_SET  65536
 
 /*
  * This is the Inode Attributes structure, used for notify_change().  It
diff -ur linux-2.6.18.x86_64~/include/linux/stat.h linux-2.6.18.x86_64/include/linux/stat.h
--- linux-2.6.18.x86_64~/include/linux/stat.h	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/include/linux/stat.h	2010-06-23 21:02:39.000000000 +0900
@@ -53,6 +53,9 @@
 #define S_IWUGO		(S_IWUSR|S_IWGRP|S_IWOTH)
 #define S_IXUGO		(S_IXUSR|S_IXGRP|S_IXOTH)
 
+#define UTIME_NOW       ((1l << 30) - 1l)
+#define UTIME_OMIT      ((1l << 30) - 2l)
+
 #include <linux/types.h>
 #include <linux/time.h>
 
diff -ur linux-2.6.18.x86_64~/include/linux/syscalls.h linux-2.6.18.x86_64/include/linux/syscalls.h
--- linux-2.6.18.x86_64~/include/linux/syscalls.h	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/include/linux/syscalls.h	2010-06-23 21:02:39.000000000 +0900
@@ -599,6 +599,8 @@
 				    size_t __user *len_ptr);
 asmlinkage long sys_set_robust_list(struct robust_list_head __user *head,
 				    size_t len);
+asmlinkage long sys_utimensat(int dfd, char __user *filename,
+			      struct timespec __user *utimes, int flags);
 asmlinkage long sys_getcpu(unsigned *cpu, unsigned *node, struct getcpu_cache *cache);
 asmlinkage long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);
 asmlinkage long sys_eventfd(unsigned int count);
diff -ur linux-2.6.18.x86_64~/include/linux/time.h linux-2.6.18.x86_64/include/linux/time.h
--- linux-2.6.18.x86_64~/include/linux/time.h	2010-06-22 20:27:11.000000000 +0900
+++ linux-2.6.18.x86_64/include/linux/time.h	2010-06-23 21:02:39.000000000 +0900
@@ -108,7 +108,7 @@
 extern int do_settimeofday(struct timespec *tv);
 extern int do_sys_settimeofday(struct timespec *tv, struct timezone *tz);
 #define do_posix_clock_monotonic_gettime(ts) ktime_get_ts(ts)
-extern long do_utimes(int dfd, char __user *filename, struct timeval *times);
+extern long do_utimes(int dfd, char __user *filename, struct timespec *times, int flags);
 struct itimerval;
 extern int do_setitimer(int which, struct itimerval *value,
 			struct itimerval *ovalue);
