diff --git a/Documentation/devicetree/bindings/phy/brcm,brcmstb-usb-phy.txt b/Documentation/devicetree/bindings/phy/brcm,brcmstb-usb-phy.txt
new file mode 100644
index 000000000000..34fa9ddb63e4
--- /dev/null
+++ b/Documentation/devicetree/bindings/phy/brcm,brcmstb-usb-phy.txt
@@ -0,0 +1,39 @@
+Broadcom STB USB PHY
+
+Required properties:
+ - compatible: brcm,brcmstb-usb-phy
+ - reg: two offset and length pairs. The second pair specifies the
+        USB 3.0 related registers and is only required for PHYs
+        that support USB 3.0
+ - #phy-cells: Shall be 1 as it expects one argument for setting
+	       the type of the PHY. Possible values are 0 (1.1 and 2.0),
+	       1 (3.0)
+
+
+Optional Properties:
+- clocks : phandle + clock specifier for the phy clocks
+- clock-names: string, clock name
+- ipp: Invert Port Power
+- ioc: Invert Over Current detection
+- has_xhci: Contains an optional 3.0 PHY
+- device: PHY Device mode. Possible values are: 0 (Host), 1 (Device)
+          or 2 (DRD)
+
+
+
+Example:
+
+usbphy_0: usb-phy@f0470200 {
+	reg = <0xf0470200 0xb8>,
+		<0xf0471940 0x6c0>;
+	#address-cells = <1>;
+	#size-cells = <1>;
+	compatible = "brcm,brcmstb-usb-phy";
+	ioc = <1>;
+	ipp = <1>;
+	#phy-cells = <1>;
+	ranges;
+	has_xhci;
+	clocks = <&sw_usb20>;
+	clock-names = "sw_usb";
+};
diff --git a/MAINTAINERS b/MAINTAINERS
index 8d365a464c6b..0e1d53232b18 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -2767,6 +2767,13 @@ S:	Maintained
 F:	drivers/bcma/
 F:	include/linux/bcma/
 
+BROADCOM STB USB PHY DRIVER
+M:	Al Cooper <alcooperx@gmail.com>
+L:	linux-usb@vger.kernel.org
+L:	bcm-kernel-feedback-list@broadcom.com
+S:	Supported
+F:	drivers/phy/phy-brcm-usb*
+
 BROADCOM SYSTEMPORT ETHERNET DRIVER
 M:	Florian Fainelli <f.fainelli@gmail.com>
 L:	netdev@vger.kernel.org
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 925081ec14c0..346f466ae49f 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -20,6 +20,7 @@ endif
 obj-$(CONFIG_MACH_ASM9260)		+= clk-asm9260.o
 obj-$(CONFIG_COMMON_CLK_AXI_CLKGEN)	+= clk-axi-clkgen.o
 obj-$(CONFIG_ARCH_AXXIA)		+= clk-axm5516.o
+obj-$(CONFIG_ARCH_BRCMSTB)		+= clk-brcmstb.o
 obj-$(CONFIG_COMMON_CLK_CDCE706)	+= clk-cdce706.o
 obj-$(CONFIG_COMMON_CLK_CDCE925)	+= clk-cdce925.o
 obj-$(CONFIG_ARCH_CLPS711X)		+= clk-clps711x.o
diff --git a/drivers/clk/clk-brcmstb.c b/drivers/clk/clk-brcmstb.c
new file mode 100644
index 000000000000..9756b819f68c
--- /dev/null
+++ b/drivers/clk/clk-brcmstb.c
@@ -0,0 +1,1067 @@
+/*
+ * Copyright (C) 2009-2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#define pr_fmt(fmt) "clk-brcmstb: " fmt
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/syscore_ops.h>
+
+static void __iomem *cpu_clk_div_reg;
+
+struct bcm_clk_gate {
+	struct clk_hw hw;
+	void __iomem *reg;
+	u8 bit_idx;
+	u8 flags;
+	u32 delay[2];
+	spinlock_t *lock;
+	struct clk_ops ops;
+};
+
+#define to_brcmstb_clk_gate(p) container_of(p, struct bcm_clk_gate, hw)
+
+static DEFINE_SPINLOCK(lock);
+
+static int cpu_clk_div_pos __initdata;
+static int cpu_clk_div_width __initdata;
+
+#ifdef CONFIG_PM_SLEEP
+static u32 cpu_clk_div_reg_dump;
+
+static int brcmstb_clk_suspend(void)
+{
+	if (cpu_clk_div_reg)
+		cpu_clk_div_reg_dump = __raw_readl(cpu_clk_div_reg);
+	return 0;
+}
+
+static void brcmstb_clk_resume(void)
+{
+	if (cpu_clk_div_reg)
+		__raw_writel(cpu_clk_div_reg_dump, cpu_clk_div_reg);
+}
+
+static struct syscore_ops brcmstb_clk_syscore_ops = {
+	.suspend = brcmstb_clk_suspend,
+	.resume = brcmstb_clk_resume,
+};
+#endif /* CONFIG_PM_SLEEP */
+
+static int __init parse_cpu_clk_div_dimensions(struct device_node *np)
+{
+	struct property *prop;
+	const __be32 *p = NULL;
+	int len;
+	int elem_cnt;
+	const char *propname = "div-shift-width";
+
+	prop = of_find_property(np, propname, &len);
+	if (!prop) {
+		pr_err("%s property undefined\n", propname);
+		return -EINVAL;
+	}
+
+	elem_cnt = len / sizeof(u32);
+
+	if (elem_cnt != 2) {
+		pr_err("%s should have only 2 elements\n", propname);
+		return -EINVAL;
+	}
+
+	p = of_prop_next_u32(prop, p, &cpu_clk_div_pos);
+	of_prop_next_u32(prop, p, &cpu_clk_div_width);
+
+	return 0;
+}
+
+static struct clk_div_table *cpu_clk_div_table;
+
+static int __init parse_cpu_clk_div_table(struct device_node *np)
+{
+	struct property *prop;
+	const __be32 *p = NULL;
+	struct clk_div_table *cur_tbl_ptr;
+	int len;
+	int elem_cnt;
+	int i;
+	const char *propname = "div-table";
+
+	prop = of_find_property(np, propname, &len);
+	if (!prop) {
+		pr_err("%s property undefined\n", propname);
+		return -EINVAL;
+	}
+
+	elem_cnt = len / sizeof(u32);
+
+	if (elem_cnt < 2) {
+		pr_err("%s should have at least 2 elements\n", propname);
+		return -EINVAL;
+	}
+
+	if ((elem_cnt % 2) != 0) {
+		pr_err("%s should have even number of elements\n", propname);
+		return -EINVAL;
+	}
+
+	/* need room for last sentinel entry */
+	len += 2 * sizeof(u32);
+
+	cpu_clk_div_table = kmalloc(len, GFP_KERNEL);
+	if (!cpu_clk_div_table)
+		return -ENOMEM;
+
+	cur_tbl_ptr = cpu_clk_div_table;
+
+	for (i = 0; i < elem_cnt; i += 2) {
+		p = of_prop_next_u32(prop, p, &cur_tbl_ptr->val);
+		p = of_prop_next_u32(prop, p, &cur_tbl_ptr->div);
+
+		cur_tbl_ptr++;
+	}
+
+	/* last entry should be zeroed out */
+	cur_tbl_ptr->val = 0;
+	cur_tbl_ptr->div = 0;
+
+	return 0;
+}
+
+static void __init of_brcmstb_cpu_clk_div_setup(struct device_node *np)
+{
+	struct clk *clk;
+	int rc;
+
+	cpu_clk_div_reg = of_iomap(np, 0);
+	if (!cpu_clk_div_reg) {
+		pr_err("unable to iomap cpu clk divider register!\n");
+		return;
+	}
+
+	rc = parse_cpu_clk_div_dimensions(np);
+	if (rc)
+		goto err;
+
+	rc = parse_cpu_clk_div_table(np);
+	if (rc)
+		goto err;
+
+	clk = clk_register_divider_table(NULL, "cpu-clk-div",
+					 of_clk_get_parent_name(np, 0), 0,
+					 cpu_clk_div_reg,
+					 cpu_clk_div_pos, cpu_clk_div_width,
+					 0, cpu_clk_div_table, &lock);
+	if (IS_ERR(clk))
+		goto err;
+
+	rc = of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	if (rc) {
+		pr_err("error adding clock provider (%d)\n", rc);
+		goto err;
+	}
+
+#ifdef CONFIG_PM_SLEEP
+	register_syscore_ops(&brcmstb_clk_syscore_ops);
+#endif
+	return;
+
+err:
+	kfree(cpu_clk_div_table);
+	cpu_clk_div_table = NULL;
+
+	if (cpu_clk_div_reg) {
+		iounmap(cpu_clk_div_reg);
+		cpu_clk_div_reg = NULL;
+	}
+}
+CLK_OF_DECLARE(brcmstb_cpu_clk_div, "brcm,brcmstb-cpu-clk-div",
+		of_brcmstb_cpu_clk_div_setup);
+
+/*
+ * It works on following logic:
+ *
+ * For enabling clock, enable = 1
+ *	set2dis = 1	-> clear bit	-> set = 0
+ *	set2dis = 0	-> set bit	-> set = 1
+ *
+ * For disabling clock, enable = 0
+ *	set2dis = 1	-> set bit	-> set = 1
+ *	set2dis = 0	-> clear bit	-> set = 0
+ *
+ * So, result is always: enable xor set2dis.
+ */
+static void brcmstb_clk_gate_endisable(struct clk_hw *hw, int enable)
+{
+	struct bcm_clk_gate *gate = to_brcmstb_clk_gate(hw);
+	int set = gate->flags & CLK_GATE_SET_TO_DISABLE ? 1 : 0;
+	unsigned long flags = 0;
+	u32 reg;
+
+	set ^= enable;
+
+	if (gate->lock)
+		spin_lock_irqsave(gate->lock, flags);
+
+	reg = readl(gate->reg);
+
+	if (set)
+		reg |= BIT(gate->bit_idx);
+	else
+		reg &= ~BIT(gate->bit_idx);
+
+	writel(reg, gate->reg);
+
+	if (set == 0 && gate->delay[0])
+		udelay(gate->delay[0]);
+	else if (set == 1 && gate->delay[1])
+		udelay(gate->delay[1]);
+
+	if (gate->lock)
+		spin_unlock_irqrestore(gate->lock, flags);
+}
+
+static int brcmstb_clk_gate_enable(struct clk_hw *hw)
+{
+	brcmstb_clk_gate_endisable(hw, 1);
+	return 0;
+}
+
+static void brcmstb_clk_gate_disable(struct clk_hw *hw)
+{
+	brcmstb_clk_gate_endisable(hw, 0);
+}
+
+static int brcmstb_clk_gate_is_enabled(struct clk_hw *hw)
+{
+	u32 reg;
+	struct bcm_clk_gate *gate = to_brcmstb_clk_gate(hw);
+
+	reg = readl(gate->reg);
+
+	/* if a set bit disables this clk, flip it before masking */
+	if (gate->flags & CLK_GATE_SET_TO_DISABLE)
+		reg ^= BIT(gate->bit_idx);
+
+	reg &= BIT(gate->bit_idx);
+	return reg ? 1 : 0;
+}
+
+static const struct clk_ops brcmstb_clk_gate_ops = {
+	.enable = brcmstb_clk_gate_enable,
+	.disable = brcmstb_clk_gate_disable,
+	.is_enabled = brcmstb_clk_gate_is_enabled,
+};
+
+static const struct clk_ops brcmstb_clk_gate_inhib_dis_ops = {
+	.enable = brcmstb_clk_gate_enable,
+	.is_enabled = brcmstb_clk_gate_is_enabled,
+};
+
+static const struct clk_ops brcmstb_clk_gate_ro_ops = {
+	.is_enabled = brcmstb_clk_gate_is_enabled,
+};
+
+/**
+ * brcm_clk_gate_register - register a bcm gate clock with the clock framework.
+ * @dev: device that is registering this clock
+ * @name: name of this clock
+ * @parent_name: name of this clock's parent
+ * @flags: framework-specific flags for this clock
+ * @reg: register address to control gating of this clock
+ * @bit_idx: which bit in the register controls gating of this clock
+ * @clk_gate_flags: gate-specific flags for this clock
+ * @delay: usec delay in turning on, off.
+ * @lock: shared register lock for this clock
+ */
+static struct clk __init *brcm_clk_gate_register(
+	struct device *dev, const char *name, const char *parent_name,
+	unsigned long flags, void __iomem *reg, u8 bit_idx,
+	u8 clk_gate_flags, u32 delay[2], spinlock_t *lock,
+	bool read_only, bool inhibit_disable)
+{
+	struct bcm_clk_gate *gate;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	/* allocate the gate */
+	gate = kzalloc(sizeof(struct bcm_clk_gate), GFP_KERNEL);
+	if (!gate) {
+		pr_err("%s: could not allocate bcm gated clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	init.ops = inhibit_disable ? &brcmstb_clk_gate_inhib_dis_ops
+		: read_only ? &brcmstb_clk_gate_ro_ops : &brcmstb_clk_gate_ops;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+	init.flags = flags;
+	init.flags |= CLK_IGNORE_UNUSED;
+
+	/* struct bcm_gate assignments */
+	gate->reg = reg;
+	gate->bit_idx = bit_idx;
+	gate->flags = clk_gate_flags;
+	gate->lock = lock;
+	gate->delay[0] = delay[0];
+	gate->delay[1] = delay[1];
+	gate->hw.init = &init;
+
+	clk = clk_register(dev, &gate->hw);
+
+	if (IS_ERR(clk))
+		kfree(gate);
+
+	return clk;
+}
+
+/**
+ * of_brcmstb_gate_clk_setup() - Setup function for brcmstb gate clock
+ */
+static void __init of_brcmstb_clk_gate_setup(struct device_node *node)
+{
+	struct clk *clk;
+	const char *clk_name = node->name;
+	void __iomem *reg;
+	const char *parent_name;
+	u8 clk_gate_flags = 0;
+	u32 bit_idx = 0;
+	u32 delay[2] = {0, 0};
+	int ret;
+	bool read_only = false;
+	bool inhibit_disable = false;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+	parent_name = of_clk_get_parent_name(node, 0);
+	if (of_property_read_u32(node, "bit-shift", &bit_idx)) {
+		pr_err("%s: missing bit-shift property for %s\n",
+				__func__, node->name);
+		return;
+	}
+	reg = of_iomap(node, 0);
+	if (!reg) {
+		pr_err("unable to iomap cpu clk divider register!\n");
+		return;
+	}
+
+	of_property_read_u32_array(node, "brcm,delay", delay, 2);
+
+	if (of_property_read_bool(node, "set-bit-to-disable"))
+		clk_gate_flags |= CLK_GATE_SET_TO_DISABLE;
+
+	if (of_property_read_bool(node, "brcm,read-only"))
+		read_only = true;
+
+	if (of_property_read_bool(node, "brcm,inhibit-disable"))
+		inhibit_disable = true;
+
+	clk = brcm_clk_gate_register(NULL, clk_name, parent_name, 0, reg,
+				     (u8) bit_idx, clk_gate_flags, delay,
+				     &lock, read_only, inhibit_disable);
+	if (!IS_ERR(clk)) {
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+		ret = clk_register_clkdev(clk, clk_name, NULL);
+		if (ret)
+			pr_err("%s: clk device registration failed for '%s'\n",
+			       __func__, clk_name);
+	}
+}
+CLK_OF_DECLARE(brcmstb_clk_gate, "brcm,brcmstb-gate-clk",
+		of_brcmstb_clk_gate_setup);
+
+struct bcm_clk_sw {
+	struct clk_hw hw;
+	u8 parent;
+	struct clk_ops ops;
+};
+
+#define to_brcmstb_clk_sw(p) container_of(p, struct bcm_clk_sw, hw)
+
+static u8 brcmstb_clk_sw_get_parent(struct clk_hw *hw)
+{
+	struct bcm_clk_sw *sw_clk = to_brcmstb_clk_sw(hw);
+
+	return sw_clk->parent;
+}
+
+static int brcmstb_clk_sw_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct bcm_clk_sw *sw_clk = to_brcmstb_clk_sw(hw);
+
+	sw_clk->parent = index;
+	return 0;
+}
+
+static const struct clk_ops brcmstb_clk_sw_ops = {
+	.get_parent = brcmstb_clk_sw_get_parent,
+	.set_parent = brcmstb_clk_sw_set_parent,
+};
+
+/**
+ * brcmstb_clk_sw_register - register a bcm gate clock with the clock framework.
+ * @dev: device that is registering this clock
+ * @name: name of this clock
+ * @parents: name of this clock's parents; not known by clock framework
+ * @num_parents: number of parents
+ * @flags: framework-specific flags for this clock
+ * @lock: shared register lock for this clock
+ */
+static struct clk __init *brcmstb_clk_sw_register(
+	struct device *dev, const char *name, const char **parent_names,
+	int num_parents, unsigned long flags, spinlock_t *lock)
+{
+	struct bcm_clk_sw *sw_clk;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	/* allocate the gate */
+	sw_clk = kzalloc(sizeof(struct bcm_clk_sw), GFP_KERNEL);
+	if (!sw_clk) {
+		pr_err("%s: could not allocate bcm sw clk\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	init.name = name;
+	init.ops = &brcmstb_clk_sw_ops;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+	init.flags = flags | CLK_IS_BASIC | CLK_IS_SW;
+	init.flags |= CLK_IGNORE_UNUSED;
+
+	sw_clk->hw.init = &init;
+	clk = clk_register(dev, &sw_clk->hw);
+	if (IS_ERR(clk))
+		kfree(sw_clk);
+	return clk;
+}
+
+static void __init of_brcmstb_clk_sw_setup(struct device_node *node)
+{
+	struct clk *clk;
+	const char *clk_name = node->name;
+	int num_parents;
+	const char **parent_names;
+	int ret, i;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+	num_parents = of_property_count_strings(node, "clock-names");
+	if (num_parents < 1) {
+		pr_err("%s: brcm-sw-clock %s must have parent(s)\n",
+				__func__, node->name);
+		return;
+	}
+	parent_names = kzalloc((sizeof(char *) * num_parents),
+			GFP_KERNEL);
+	if (!parent_names) {
+		pr_err("%s: failed to alloc parent_names\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < num_parents; i++)
+		parent_names[i] = of_clk_get_parent_name(node, i);
+
+	clk = brcmstb_clk_sw_register(NULL, clk_name, parent_names, num_parents,
+				   0, NULL);
+	kfree(parent_names);
+
+	if (!IS_ERR(clk)) {
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+		ret = clk_register_clkdev(clk, clk_name, NULL);
+		if (ret)
+			pr_err("%s: clk device registration failed for '%s'\n",
+			       __func__, clk_name);
+	}
+}
+CLK_OF_DECLARE(brcmstb_clk_sw, "brcm,brcmstb-sw-clk",
+		of_brcmstb_clk_sw_setup);
+
+static struct clk_div_table *of_clk_get_div_table(struct device_node *node)
+{
+	int i;
+	unsigned int table_size;
+	struct clk_div_table *table;
+	const __be32 *tablespec;
+	u32 val;
+
+	tablespec = of_get_property(node, "table", (int *) &table_size);
+
+	if (!tablespec)
+		return NULL;
+
+	table_size /= sizeof(struct clk_div_table);
+
+	table = kzalloc(sizeof(struct clk_div_table) * table_size, GFP_KERNEL);
+	if (!table) {
+		pr_err("%s: unable to allocate memory for %s table\n", __func__,
+		       node->name);
+		return NULL;
+	}
+
+	for (i = 0; i < table_size; i++) {
+		of_property_read_u32_index(node, "table", i * 2, &val);
+		table[i].div = val;
+		of_property_read_u32_index(node, "table", i * 2 + 1, &val);
+		table[i].val = val;
+	}
+
+	return table;
+}
+
+/**
+ * of_divider_clk_setup() - Setup function for simple div rate clock
+ */
+static void __init of_divider_clk_setup(struct device_node *node)
+{
+	struct clk *clk;
+	const char *clk_name = node->name;
+	void __iomem *reg;
+	const char *parent_name;
+	u8 clk_divider_flags = 0;
+	u32 mask = 0;
+	u32 shift = 0;
+	u32 width;
+	struct clk_div_table *table;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	reg = of_iomap(node, 0);
+	if (!reg) {
+		pr_err("%s: no memory mapped for property reg\n", __func__);
+		return;
+	}
+
+	if (of_property_read_u32(node, "bit-mask", &mask)) {
+		pr_err("%s: missing bit-mask property for %s\n", __func__,
+		       node->name);
+		return;
+	}
+	width = fls(mask);
+	if ((1 << width) - 1 != mask) {
+		pr_err("%s: bad bit-mask for %s\n", __func__, node->name);
+		return;
+	}
+
+	if (of_property_read_u32(node, "bit-shift", &shift)) {
+		shift = __ffs(mask);
+		pr_debug("%s: bit-shift property defaults to 0x%x for %s\n",
+				__func__, shift, node->name);
+	}
+
+	if (of_property_read_bool(node, "index-starts-at-one"))
+		clk_divider_flags |= CLK_DIVIDER_ONE_BASED;
+
+	if (of_property_read_bool(node, "index-power-of-two"))
+		clk_divider_flags |= CLK_DIVIDER_POWER_OF_TWO;
+
+	if (of_property_read_bool(node, "index-allow-zero"))
+		clk_divider_flags |= CLK_DIVIDER_ALLOW_ZERO;
+
+	if (of_property_read_bool(node, "index-max-mult-at-zero"))
+		clk_divider_flags |= CLK_DIVIDER_MAX_AT_ZERO;
+
+	if (of_property_read_bool(node, "hiword-mask"))
+		clk_divider_flags |= CLK_DIVIDER_HIWORD_MASK;
+
+	table = of_clk_get_div_table(node);
+	if (IS_ERR(table))
+		return;
+
+	clk = clk_register_divider_table(NULL, clk_name, parent_name, 0, reg, shift,
+			width, clk_divider_flags, table, NULL);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+CLK_OF_DECLARE(divider_clk, "divider-clock", of_divider_clk_setup);
+
+#define CLK_MULTIPLIER_ONE_BASED	BIT(0)
+#define CLK_MULTIPLIER_POWER_OF_TWO	BIT(1)
+#define CLK_MULTIPLIER_ALLOW_ZERO	BIT(2)
+#define CLK_MULTIPLIER_HIWORD_MASK	BIT(3)
+#define CLK_MULTIPLIER_READ_ONLY	BIT(4)
+#define CLK_MULTIPLIER_MAX_MULT_AT_ZERO	BIT(5)
+
+/*
+ * DOC: basic adjustable multiplier clock that cannot gate
+ *
+ * Traits of this clock:
+ * prepare - clk_prepare only ensures that parents are prepared
+ * enable - clk_enable only ensures that parents are enabled
+ * rate - rate is adjustable.  clk->rate = (parent->rate * multiplier)
+ * parent - fixed parent.  No clk_set_parent support
+ */
+
+#define to_clk_multiplier(_hw) container_of(_hw, struct clk_multiplier, hw)
+
+#define mult_mask(width)	((1 << (width)) - 1)
+
+static unsigned int _get_table_minmult(const struct clk_mult_table *table)
+{
+	unsigned int minmult = UINT_MAX;
+	const struct clk_mult_table *clkt;
+
+	for (clkt = table; clkt->mult; clkt++)
+		if (clkt->mult < minmult)
+			minmult = clkt->mult;
+	return minmult;
+}
+
+static unsigned int _get_table_maxmult(const struct clk_mult_table *table)
+{
+	unsigned int maxmult = 0;
+	const struct clk_mult_table *clkt;
+
+	for (clkt = table; clkt->mult; clkt++)
+		if (clkt->mult > maxmult)
+			maxmult = clkt->mult;
+	return maxmult;
+}
+
+static unsigned int _get_minmult(const struct clk_mult_table *table)
+{
+	if (table)
+		return _get_table_minmult(table);
+	return 1;
+}
+
+static unsigned int _get_maxmult(const struct clk_mult_table *table, u8 width,
+				unsigned long flags)
+{
+	if (flags & CLK_MULTIPLIER_ONE_BASED)
+		return mult_mask(width);
+	if (flags & CLK_MULTIPLIER_POWER_OF_TWO)
+		return 1 << mult_mask(width);
+	if (table)
+		return _get_table_maxmult(table);
+	return mult_mask(width) + 1;
+}
+
+static unsigned int _get_table_mult(const struct clk_mult_table *table,
+							unsigned int val)
+{
+	const struct clk_mult_table *clkt;
+
+	for (clkt = table; clkt->mult; clkt++)
+		if (clkt->val == val)
+			return clkt->mult;
+	return 0;
+}
+
+static unsigned int _get_mult(const struct clk_mult_table *table,
+			      u8 width, unsigned int val, unsigned long flags)
+{
+	if (flags & CLK_MULTIPLIER_ONE_BASED)
+		return val;
+	if (flags & CLK_MULTIPLIER_POWER_OF_TWO)
+		return 1 << val;
+	if (flags & CLK_MULTIPLIER_MAX_MULT_AT_ZERO)
+		return val ? val : mult_mask(width) + 1;
+	if (table)
+		return _get_table_mult(table, val);
+	return val + 1;
+}
+
+static unsigned int _get_table_val(const struct clk_mult_table *table,
+				   unsigned int mult)
+{
+	const struct clk_mult_table *clkt;
+
+	for (clkt = table; clkt->mult; clkt++)
+		if (clkt->mult == mult)
+			return clkt->val;
+	return 0;
+}
+
+static unsigned int _get_val(const struct clk_mult_table *table,
+			     u8 width, unsigned int mult, unsigned long flags)
+{
+	if (flags & CLK_MULTIPLIER_ONE_BASED)
+		return mult;
+	if (flags & CLK_MULTIPLIER_POWER_OF_TWO)
+		return __ffs(mult);
+	if (flags & CLK_MULTIPLIER_MAX_MULT_AT_ZERO)
+		return (mult == mult_mask(width) + 1)
+			? 0 : mult;
+	if (table)
+		return  _get_table_val(table, mult);
+	return mult - 1;
+}
+
+static unsigned long multiplier_recalc_rate(struct clk_hw *hw,
+				     unsigned long parent_rate,
+				     unsigned int val,
+				     const struct clk_mult_table *table,
+				     unsigned long flags)
+{
+	struct clk_multiplier *multiplier = to_clk_multiplier(hw);
+	unsigned int mult;
+
+	mult = _get_mult(table, multiplier->width, val, flags);
+	if (!mult) {
+		WARN(!(flags & CLK_MULTIPLIER_ALLOW_ZERO),
+			"%s: Zero multiplier and CLK_MULTIPLIER_ALLOW_ZERO not set\n",
+			__clk_get_name(hw->clk));
+		return parent_rate;
+	}
+
+	return parent_rate * mult;
+}
+
+static unsigned long clk_multiplier_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct clk_multiplier *multiplier = to_clk_multiplier(hw);
+	unsigned int val;
+
+	val = clk_readl(multiplier->reg) >> multiplier->shift;
+	val &= mult_mask(multiplier->width);
+
+	return multiplier_recalc_rate(hw, parent_rate, val, multiplier->table,
+				   multiplier->flags);
+}
+
+static bool _is_valid_table_mult(const struct clk_mult_table *table,
+							 unsigned int mult)
+{
+	const struct clk_mult_table *clkt;
+
+	for (clkt = table; clkt->mult; clkt++)
+		if (clkt->mult == mult)
+			return true;
+	return false;
+}
+
+static bool _is_valid_mult(const struct clk_mult_table *table,
+			   unsigned int mult, unsigned long flags)
+{
+	if (flags & CLK_MULTIPLIER_POWER_OF_TWO)
+		return is_power_of_2(mult);
+	if (table)
+		return _is_valid_table_mult(table, mult);
+	return true;
+}
+
+static int clk_multiplier_bestmult(struct clk_hw *hw, unsigned long rate,
+			       unsigned long *best_parent_rate,
+			       const struct clk_mult_table *table, u8 width,
+			       unsigned long flags)
+{
+	int i, bestmult = 0;
+	unsigned long parent_rate, best = 0, now, maxmult, minmult;
+	unsigned long parent_rate_saved = *best_parent_rate;
+
+	if (!rate)
+		rate = 1;
+
+	minmult = _get_minmult(table);
+	maxmult = _get_maxmult(table, width, flags);
+
+	if (!(__clk_get_flags(hw->clk) & CLK_SET_RATE_PARENT)) {
+		parent_rate = *best_parent_rate;
+		bestmult = rate / parent_rate;
+		bestmult = bestmult == 0 ? minmult : bestmult;
+		bestmult = bestmult > maxmult ? maxmult : bestmult;
+		return bestmult;
+	}
+
+	/*
+	 * The maximum multiplier we can use without overflowing
+	 * unsigned long in rate * i below
+	 */
+	maxmult = min(ULONG_MAX / parent_rate_saved, maxmult);
+
+	for (i = 1; i <= maxmult; i++) {
+		if (!_is_valid_mult(table, i, flags))
+			continue;
+		if (rate == parent_rate_saved * i) {
+			/*
+			 * It's the most ideal case if the requested rate can be
+			 * multiplied from parent clock without needing to
+			 * change the parent rate, so return the multiplier
+			 * immediately.
+			 */
+			*best_parent_rate = parent_rate_saved;
+			return i;
+		}
+		parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),
+					       rate / i);
+		now = parent_rate * i;
+		if (now <= rate && now > best) {
+			bestmult = i;
+			best = now;
+			*best_parent_rate = parent_rate;
+		}
+	}
+
+	if (!bestmult) {
+		bestmult = _get_minmult(table);
+		*best_parent_rate
+			= clk_hw_round_rate(clk_hw_get_parent(hw), 1);
+	}
+
+	return bestmult;
+}
+
+static long multiplier_round_rate(struct clk_hw *hw, unsigned long rate,
+			   unsigned long *prate,
+			   const struct clk_mult_table *table,
+			   u8 width, unsigned long flags)
+{
+	int mult;
+
+	mult = clk_multiplier_bestmult(hw, rate, prate, table, width, flags);
+
+	return *prate * mult;
+}
+
+static long clk_multiplier_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *prate)
+{
+	struct clk_multiplier *multiplier = to_clk_multiplier(hw);
+	int bestmult;
+
+	/* if read only, just return current value */
+	if (multiplier->flags & CLK_MULTIPLIER_READ_ONLY) {
+		bestmult = readl(multiplier->reg) >> multiplier->shift;
+		bestmult &= mult_mask(multiplier->width);
+		bestmult = _get_mult(multiplier->table, multiplier->width,
+				     bestmult, multiplier->flags);
+		if ((__clk_get_flags(hw->clk) & CLK_SET_RATE_PARENT))
+			*prate = clk_hw_round_rate(clk_hw_get_parent(hw),
+						  rate);
+		return *prate * bestmult;
+	}
+
+	return multiplier_round_rate(hw, rate, prate, multiplier->table,
+				  multiplier->width, multiplier->flags);
+}
+
+static int multiplier_get_val(unsigned long rate, unsigned long parent_rate,
+		    const struct clk_mult_table *table, u8 width,
+		    unsigned long flags)
+{
+	unsigned int mult, value;
+
+	mult = rate / parent_rate;
+	value = _get_val(table, width, mult, flags);
+	return min_t(unsigned int, value, mult_mask(width));
+}
+
+static int clk_multiplier_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct clk_multiplier *multiplier = to_clk_multiplier(hw);
+	unsigned int value;
+	unsigned long flags = 0;
+	u32 val;
+
+	value = multiplier_get_val(rate, parent_rate, multiplier->table,
+				multiplier->width, multiplier->flags);
+
+	if (multiplier->lock)
+		spin_lock_irqsave(multiplier->lock, flags);
+
+	if (multiplier->flags & CLK_MULTIPLIER_HIWORD_MASK) {
+		val = mult_mask(multiplier->width) << (multiplier->shift + 16);
+	} else {
+		val = clk_readl(multiplier->reg);
+		val &= ~(mult_mask(multiplier->width) << multiplier->shift);
+	}
+	val |= value << multiplier->shift;
+	clk_writel(val, multiplier->reg);
+
+	if (multiplier->lock)
+		spin_unlock_irqrestore(multiplier->lock, flags);
+
+	return 0;
+}
+
+static const struct clk_ops bcm_clk_multiplier_ops = {
+	.recalc_rate = clk_multiplier_recalc_rate,
+	.round_rate = clk_multiplier_round_rate,
+	.set_rate = clk_multiplier_set_rate,
+};
+
+static const struct clk_ops bcm_clk_multiplier_ro_ops = {
+	.recalc_rate = clk_multiplier_recalc_rate,
+};
+
+static struct clk *_register_multiplier(struct device *dev, const char *name,
+		const char *parent_name, unsigned long flags,
+		void __iomem *reg, u8 shift, u8 width,
+		u8 clk_multiplier_flags, const struct clk_mult_table *table,
+		spinlock_t *lock)
+{
+	struct clk_multiplier *mult;
+	struct clk *clk;
+	struct clk_init_data init;
+
+	if (clk_multiplier_flags & CLK_MULTIPLIER_HIWORD_MASK) {
+		if (width + shift > 16) {
+			pr_warn("multiplier value exceeds LOWORD field\n");
+			return ERR_PTR(-EINVAL);
+		}
+	}
+
+	/* allocate the multiplier */
+	mult = kzalloc(sizeof(struct clk_multiplier), GFP_KERNEL);
+	if (!mult)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	if (clk_multiplier_flags & CLK_MULTIPLIER_READ_ONLY)
+		init.ops = &bcm_clk_multiplier_ro_ops;
+	else
+		init.ops = &bcm_clk_multiplier_ops;
+	init.flags = flags | CLK_IS_BASIC;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	/* struct clk_multiplier assignments */
+	mult->reg = reg;
+	mult->shift = shift;
+	mult->width = width;
+	mult->flags = clk_multiplier_flags;
+	mult->lock = lock;
+	mult->hw.init = &init;
+	mult->table = table;
+
+	/* register the clock */
+	clk = clk_register(dev, &mult->hw);
+
+	if (IS_ERR(clk))
+		kfree(mult);
+
+	return clk;
+}
+
+static struct clk_mult_table *of_clk_get_mult_table(struct device_node *node)
+{
+	int i;
+	unsigned int table_size;
+	struct clk_mult_table *table;
+	const __be32 *tablespec;
+	u32 val;
+
+	tablespec = of_get_property(node, "table", (int *) &table_size);
+
+	if (!tablespec)
+		return NULL;
+
+	table_size /= sizeof(struct clk_mult_table);
+
+	if (!table_size) {
+		pr_err("%s: %s table has zero length\n", __func__,
+		       node->name);
+		return ERR_PTR(-EINVAL);
+	}
+
+	table = kzalloc(sizeof(struct clk_mult_table) * (table_size + 1),
+			GFP_KERNEL);
+	if (!table) {
+		pr_err("%s: unable to allocate memory for %s table\n", __func__,
+		       node->name);
+		return NULL;
+	}
+
+	for (i = 0; i < table_size; i++) {
+		of_property_read_u32_index(node, "table", i * 2, &val);
+		table[i].mult = val;
+		of_property_read_u32_index(node, "table", i * 2 + 1, &val);
+		table[i].val = val;
+	}
+
+	return table;
+}
+
+/**
+ * of_multiplier_clk_setup() - Setup function for simple mult rate clock
+ */
+static void __init of_multiplier_clk_setup(struct device_node *node)
+{
+	struct clk *clk;
+	const char *clk_name = node->name;
+	void __iomem *reg;
+	const char *parent_name;
+	u8 clk_multiplier_flags = 0;
+	u32 mask = 0;
+	u32 shift = 0;
+	u32 width;
+	struct clk_mult_table *table;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	reg = of_iomap(node, 0);
+	if (!reg) {
+		pr_err("%s: no memory mapped for property reg\n", __func__);
+		return;
+	}
+
+	if (of_property_read_u32(node, "bit-mask", &mask)) {
+		pr_err("%s: missing bit-mask property for %s\n", __func__,
+		       node->name);
+		return;
+	}
+	width = fls(mask);
+	if ((1 << width) - 1 != mask) {
+		pr_err("%s: bad bit-mask for %s\n", __func__, node->name);
+		return;
+	}
+
+	if (of_property_read_u32(node, "bit-shift", &shift)) {
+		shift = __ffs(mask);
+		pr_debug("%s: bit-shift property defaults to 0x%x for %s\n",
+				__func__, shift, node->name);
+	}
+
+	if (of_property_read_bool(node, "index-starts-at-one"))
+		clk_multiplier_flags |= CLK_MULTIPLIER_ONE_BASED;
+
+	if (of_property_read_bool(node, "index-power-of-two"))
+		clk_multiplier_flags |= CLK_MULTIPLIER_POWER_OF_TWO;
+
+	if (of_property_read_bool(node, "index-allow-zero"))
+		clk_multiplier_flags |= CLK_MULTIPLIER_ALLOW_ZERO;
+
+	if (of_property_read_bool(node, "index-max-mult-at-zero"))
+		clk_multiplier_flags |= CLK_MULTIPLIER_MAX_MULT_AT_ZERO;
+
+	table = of_clk_get_mult_table(node);
+	if (IS_ERR(table))
+		return;
+
+	clk = _register_multiplier(NULL, clk_name, parent_name, 0, reg, shift,
+			width, clk_multiplier_flags, table, NULL);
+
+	if (!IS_ERR(clk))
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+}
+CLK_OF_DECLARE(multiplier_clk, "multiplier-clock", of_multiplier_clk_setup);
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 0fb39fe217d1..c907931a5d00 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -38,6 +38,7 @@ static int enable_refcnt;
 static HLIST_HEAD(clk_root_list);
 static HLIST_HEAD(clk_orphan_list);
 static LIST_HEAD(clk_notifier_list);
+static HLIST_HEAD(clk_sw_list);
 
 /***    private data structures    ***/
 
@@ -490,7 +491,14 @@ static void clk_core_unprepare(struct clk_core *core)
 		core->ops->unprepare(core->hw);
 
 	trace_clk_unprepare_complete(core);
-	clk_core_unprepare(core->parent);
+	if (core->flags & CLK_IS_SW) {
+		int i;
+
+		for (i = 0; i < core->num_parents; i++)
+			clk_core_unprepare(core->parents[i]);
+	} else {
+		clk_core_unprepare(core->parent);
+	}
 }
 
 static void clk_core_unprepare_lock(struct clk_core *core)
@@ -530,7 +538,20 @@ static int clk_core_prepare(struct clk_core *core)
 		return 0;
 
 	if (core->prepare_count == 0) {
-		ret = clk_core_prepare(core->parent);
+		if (core->flags & CLK_IS_SW) {
+			int i, j;
+
+			for (i = 0; i < core->num_parents; i++) {
+				ret = clk_core_prepare(core->parents[i]);
+				if (ret) {
+					for (j = i - 1; j >= 0; j--)
+						clk_core_unprepare(core->parents[j]);
+					break;
+				}
+			}
+		} else {
+			ret = clk_core_prepare(core->parent);
+		}
 		if (ret)
 			return ret;
 
@@ -606,8 +627,14 @@ static void clk_core_disable(struct clk_core *core)
 		core->ops->disable(core->hw);
 
 	trace_clk_disable_complete_rcuidle(core);
+	if (core->flags & CLK_IS_SW) {
+		int i;
 
-	clk_core_disable(core->parent);
+		for (i = 0; i < core->num_parents; i++)
+			clk_core_disable(core->parents[i]);
+	} else {
+		clk_core_disable(core->parent);
+	}
 }
 
 static void clk_core_disable_lock(struct clk_core *core)
@@ -653,7 +680,20 @@ static int clk_core_enable(struct clk_core *core)
 		return -ESHUTDOWN;
 
 	if (core->enable_count == 0) {
-		ret = clk_core_enable(core->parent);
+		if (core->flags & CLK_IS_SW) {
+			int i, j;
+
+			for (i = 0; i < core->num_parents && !ret; i++) {
+				ret = clk_core_enable(core->parents[i]);
+				if (ret) {
+					for (j = i - 1; j >= 0; j--)
+						clk_core_disable(core->parents[j]);
+					break;
+				}
+			}
+		} else {
+			ret = clk_core_enable(core->parent);
+		}
 
 		if (ret)
 			return ret;
@@ -2392,6 +2432,9 @@ static int __clk_core_init(struct clk_core *core)
 	} else if (!core->num_parents) {
 		hlist_add_head(&core->child_node, &clk_root_list);
 		core->orphan = false;
+	} else if (core->flags & CLK_IS_SW) {
+		hlist_add_head(&core->child_node, &clk_sw_list);
+		core->orphan = false;
 	} else {
 		hlist_add_head(&core->child_node, &clk_orphan_list);
 		core->orphan = true;
diff --git a/drivers/phy/Kconfig b/drivers/phy/Kconfig
index fe00f9134d51..95d90c7ec6e5 100644
--- a/drivers/phy/Kconfig
+++ b/drivers/phy/Kconfig
@@ -479,6 +479,16 @@ config PHY_CYGNUS_PCIE
 	  Enable this to support the Broadcom Cygnus PCIe PHY.
 	  If unsure, say N.
 
+config BRCM_USB_PHY
+	tristate "Broadcom USB PHY driver"
+	depends on OF && USB && ARCH_BRCMSTB
+	select GENERIC_PHY
+	default y
+	help
+	  Enable this to support the Broadcom USB PHY on
+	  Broadcom STB SoCs.
+	  If unsure, say Y.
+
 source "drivers/phy/tegra/Kconfig"
 
 config PHY_NS2_PCIE
diff --git a/drivers/phy/Makefile b/drivers/phy/Makefile
index a534cf5be07d..96e991521665 100644
--- a/drivers/phy/Makefile
+++ b/drivers/phy/Makefile
@@ -11,6 +11,8 @@ obj-$(CONFIG_PHY_DA8XX_USB)		+= phy-da8xx-usb.o
 obj-$(CONFIG_PHY_DM816X_USB)		+= phy-dm816x-usb.o
 obj-$(CONFIG_ARMADA375_USBCLUSTER_PHY)	+= phy-armada375-usb2.o
 obj-$(CONFIG_BCM_KONA_USB2_PHY)		+= phy-bcm-kona-usb2.o
+obj-$(CONFIG_BRCM_USB_PHY)		+= phy-brcm-usb.o
+obj-$(CONFIG_BRCM_USB_PHY)		+= phy-brcm-usb-init.o
 obj-$(CONFIG_PHY_EXYNOS_DP_VIDEO)	+= phy-exynos-dp-video.o
 obj-$(CONFIG_PHY_EXYNOS_MIPI_VIDEO)	+= phy-exynos-mipi-video.o
 obj-$(CONFIG_PHY_LPC18XX_USB_OTG)	+= phy-lpc18xx-usb-otg.o
diff --git a/drivers/phy/phy-brcm-usb-init.c b/drivers/phy/phy-brcm-usb-init.c
new file mode 100644
index 000000000000..18fcc59df8b1
--- /dev/null
+++ b/drivers/phy/phy-brcm-usb-init.c
@@ -0,0 +1,791 @@
+/*
+ * Copyright (C) 2014-2016 Broadcom
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * This module is used by both the bootloader and Linux and
+ * contains USB initialization for power up and S3 resume.
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include <linux/soc/brcmstb/brcmstb.h>
+#include "phy-brcm-usb-init.h"
+
+/* Register definitions for the USB CTRL block */
+#define USB_CTRL_SETUP			0x00
+#define   USB_CTRL_SETUP_IOC_MASK			0x00000010
+#define   USB_CTRL_SETUP_IPP_MASK			0x00000020
+#define   USB_CTRL_SETUP_BABO_MASK			0x00000001
+#define   USB_CTRL_SETUP_FNHW_MASK			0x00000002
+#define   USB_CTRL_SETUP_FNBO_MASK			0x00000004
+#define   USB_CTRL_SETUP_WABO_MASK			0x00000008
+#define   USB_CTRL_SETUP_scb1_en_MASK			0x00004000 /* option */
+#define   USB_CTRL_SETUP_scb2_en_MASK			0x00008000 /* option */
+#define   USB_CTRL_SETUP_ss_ehci64bit_en_MASK		0x00020000 /* option */
+#define   USB_CTRL_SETUP_ss_ehci64bit_en_var_MASK	0x00010000 /* option */
+#define   USB_CTRL_SETUP_strap_ipp_sel_MASK		0x02000000 /* option */
+#define   USB_CTRL_SETUP_OC3_DISABLE_MASK		0xc0000000 /* option */
+#define USB_CTRL_PLL_CTL		0x04
+#define   USB_CTRL_PLL_CTL_PLL_SUSPEND_EN_MASK		0x08000000
+#define   USB_CTRL_PLL_CTL_PLL_RESETB_MASK		0x40000000
+#define   USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK		0x80000000 /* option */
+#define USB_CTRL_EBRIDGE		0x0c
+#define   USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK		0x00020000 /* option */
+#define USB_CTRL_MDIO			0x14
+#define USB_CTRL_MDIO2			0x18
+#define USB_CTRL_UTMI_CTL_1		0x2c
+#define   USB_CTRL_UTMI_CTL_1_POWER_UP_FSM_EN_MASK	0x00000800
+#define   USB_CTRL_UTMI_CTL_1_POWER_UP_FSM_EN_P1_MASK	0x08000000
+#define USB_CTRL_USB_PM			0x34
+#define   USB_CTRL_USB_PM_bdc_soft_resetb_MASK		0x00800000 /* option */
+#define   USB_CTRL_USB_PM_xhc_soft_resetb_MASK		0x00400000 /* option */
+#define   USB_CTRL_USB_PM_xhc_soft_resetb_var_MASK	0x40000000 /* option */
+#define   USB_CTRL_USB_PM_USB_PWRDN_MASK		0x80000000 /* option */
+#define USB_CTRL_USB30_CTL1		0x60
+#define   USB_CTRL_USB30_CTL1_phy3_pll_seq_start_MASK	0x00000010
+#define   USB_CTRL_USB30_CTL1_phy3_resetb_MASK		0x00010000
+#define   USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK	0x00020000 /* option */
+#define   USB_CTRL_USB30_CTL1_usb3_ioc_MASK		0x10000000 /* option */
+#define   USB_CTRL_USB30_CTL1_usb3_ipp_MASK		0x20000000 /* option */
+#define USB_CTRL_USB30_PCTL		0x70
+#define   USB_CTRL_USB30_PCTL_PHY3_SOFT_RESETB_MASK	0x00000002
+#define   USB_CTRL_USB30_PCTL_PHY3_SOFT_RESETB_P1_MASK	0x00020000
+#define USB_CTRL_USB_DEVICE_CTL1	0x90
+#define   USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK	0x00000003 /* option */
+
+/* Register definitions for the XHCI EC block */
+#define USB_XHCI_EC_IRAADR 0x658
+#define USB_XHCI_EC_IRADAT 0x65c
+
+enum brcm_family_type {
+	BRCM_FAMILY_DEFAULT,
+	BRCM_FAMILY_3390A0,
+	BRCM_FAMILY_7250B0,
+	BRCM_FAMILY_7271A0,
+	BRCM_FAMILY_7364A0,
+	BRCM_FAMILY_7366C0,
+	BRCM_FAMILY_74371A0,
+	BRCM_FAMILY_7439B0,
+	BRCM_FAMILY_7445D0,
+	BRCM_FAMILY_COUNT,
+};
+
+enum {
+	USB_CTRL_SETUP_scb1_en_SELECTOR,
+	USB_CTRL_SETUP_scb2_en_SELECTOR,
+	USB_CTRL_SETUP_ss_ehci64bit_en_SELECTOR,
+	USB_CTRL_SETUP_strap_ipp_sel_SELECTOR,
+	USB_CTRL_SETUP_OC3_DISABLE_SELECTOR,
+	USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_SELECTOR,
+	USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_SELECTOR,
+	USB_CTRL_USB_PM_bdc_soft_resetb_SELECTOR,
+	USB_CTRL_USB_PM_xhc_soft_resetb_SELECTOR,
+	USB_CTRL_USB_PM_USB_PWRDN_SELECTOR,
+	USB_CTRL_USB30_CTL1_xhc_soft_resetb_SELECTOR,
+	USB_CTRL_USB30_CTL1_usb3_ioc_SELECTOR,
+	USB_CTRL_USB30_CTL1_usb3_ipp_SELECTOR,
+	USB_CTRL_USB_DEVICE_CTL1_port_mode_SELECTOR,
+	USB_CTRL_SELECTOR_COUNT,
+};
+
+#define USB_CTRL_REG(base, reg)	((void *)base + USB_CTRL_##reg)
+#define USB_XHCI_EC_REG(base, reg) ((void *)base + USB_XHCI_EC_##reg)
+#define USB_CTRL_MASK(reg, field) \
+	USB_CTRL_##reg##_##field##_MASK
+#define USB_CTRL_MASK_FAMILY(reg, field) \
+	(usb_reg_bits_map[USB_CTRL_##reg##_##field##_SELECTOR])
+
+#define USB_CTRL_SET_FAMILY(base, reg, field)	\
+	usb_ctrl_set_family(USB_CTRL_REG(base, reg),	\
+			USB_CTRL_##reg##_##field##_SELECTOR)
+#define USB_CTRL_UNSET_FAMILY(base, reg, field)	\
+	usb_ctrl_unset_family(USB_CTRL_REG(base, reg),	\
+		USB_CTRL_##reg##_##field##_SELECTOR)
+#define USB_CTRL_SET(base, reg, field)	\
+	usb_ctrl_set(USB_CTRL_REG(base, reg),	\
+		USB_CTRL_##reg##_##field##_MASK)
+#define USB_CTRL_UNSET(base, reg, field)	\
+	usb_ctrl_unset(USB_CTRL_REG(base, reg),	\
+		USB_CTRL_##reg##_##field##_MASK)
+
+#define MDIO_USB2	0
+#define MDIO_USB3	(1 << 31)
+
+#define USB_CTRL_SETUP_CONDITIONAL_BITS (	\
+		USB_CTRL_MASK(SETUP, BABO) |	\
+		USB_CTRL_MASK(SETUP, FNHW) |	\
+		USB_CTRL_MASK(SETUP, FNBO) |	\
+		USB_CTRL_MASK(SETUP, WABO) |	\
+		USB_CTRL_MASK(SETUP, IOC)  |	\
+		USB_CTRL_MASK(SETUP, IPP))
+
+#ifdef __LITTLE_ENDIAN
+#define ENDIAN_SETTINGS (			\
+		USB_CTRL_MASK(SETUP, BABO) |	\
+		USB_CTRL_MASK(SETUP, FNHW))
+#else
+#define ENDIAN_SETTINGS (			\
+		USB_CTRL_MASK(SETUP, FNHW) |	\
+		USB_CTRL_MASK(SETUP, FNBO) |	\
+		USB_CTRL_MASK(SETUP, WABO))
+#endif
+
+struct id_to_type {
+	uint32_t id;
+	int type;
+};
+
+static const struct id_to_type id_to_type_table[] = {
+	{ 0x33900000, BRCM_FAMILY_3390A0 },
+	{ 0x33900010, BRCM_FAMILY_3390A0 },
+	{ 0x72500010, BRCM_FAMILY_7250B0 },
+	{ 0x72710000, BRCM_FAMILY_7271A0 },
+	{ 0x72680000, BRCM_FAMILY_7271A0 },
+	{ 0x73640000, BRCM_FAMILY_7364A0 },
+	{ 0x73640010, BRCM_FAMILY_7364A0 },
+	{ 0x73660020, BRCM_FAMILY_7366C0 },
+	{ 0x74371000, BRCM_FAMILY_74371A0 },
+	{ 0x74390010, BRCM_FAMILY_7439B0 },
+	{ 0x74450030, BRCM_FAMILY_7445D0 },
+	{ 0x74450040, BRCM_FAMILY_7445D0 },
+};
+
+static const uint32_t *usb_reg_bits_map;
+static enum brcm_family_type my_family;
+
+static const uint32_t
+usb_reg_bits_map_table[BRCM_FAMILY_COUNT][USB_CTRL_SELECTOR_COUNT] = {
+	/* DEFAULT (default to latest chip, currently the 7271) */
+	[BRCM_FAMILY_DEFAULT] = {
+		USB_CTRL_SETUP_scb1_en_MASK,
+		USB_CTRL_SETUP_scb2_en_MASK,
+		USB_CTRL_SETUP_ss_ehci64bit_en_var_MASK,
+		0, /* USB_CTRL_SETUP_strap_ipp_sel_MASK */
+		0, /* USB_CTRL_SETUP_OC3_DISABLE_MASK */
+		USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK,
+		0, /* USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK */
+		0, /* USB_CTRL_USB_PM_bdc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB_PM_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB_PM_USB_PWRDN_MASK */
+		USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK,
+		USB_CTRL_USB30_CTL1_usb3_ioc_MASK,
+		USB_CTRL_USB30_CTL1_usb3_ipp_MASK,
+		0, /* USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK */
+	},
+	/* 3390B0 */
+	[BRCM_FAMILY_3390A0] = {
+		USB_CTRL_SETUP_scb1_en_MASK,
+		USB_CTRL_SETUP_scb2_en_MASK,
+		USB_CTRL_SETUP_ss_ehci64bit_en_MASK,
+		USB_CTRL_SETUP_strap_ipp_sel_MASK,
+		USB_CTRL_SETUP_OC3_DISABLE_MASK,
+		0, /* USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK */
+		USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK,
+		0, /* USB_CTRL_USB_PM_bdc_soft_resetb_MASK */
+		USB_CTRL_USB_PM_xhc_soft_resetb_MASK,
+		USB_CTRL_USB_PM_USB_PWRDN_MASK,
+		0, /* USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ioc_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ipp_MASK */
+		USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK,
+	},
+	/* 7250b0 */
+	[BRCM_FAMILY_7250B0] = {
+		USB_CTRL_SETUP_scb1_en_MASK,
+		USB_CTRL_SETUP_scb2_en_MASK,
+		USB_CTRL_SETUP_ss_ehci64bit_en_MASK,
+		0, /* USB_CTRL_SETUP_strap_ipp_sel_MASK */
+		USB_CTRL_SETUP_OC3_DISABLE_MASK,
+		USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK,
+		USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK,
+		0, /* USB_CTRL_USB_PM_bdc_soft_resetb_MASK */
+		USB_CTRL_USB_PM_xhc_soft_resetb_var_MASK,
+		0, /* USB_CTRL_USB_PM_USB_PWRDN_MASK */
+		0, /* USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ioc_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ipp_MASK */
+		0, /* USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK */
+	},
+	/* 7271a0 */
+	[BRCM_FAMILY_7271A0] = {
+		0, /* USB_CTRL_SETUP_scb1_en_MASK */
+		0, /* USB_CTRL_SETUP_scb2_en_MASK */
+		USB_CTRL_SETUP_ss_ehci64bit_en_MASK,
+		USB_CTRL_SETUP_strap_ipp_sel_MASK,
+		USB_CTRL_SETUP_OC3_DISABLE_MASK,
+		0, /* USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK */
+		USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK,
+		USB_CTRL_USB_PM_bdc_soft_resetb_MASK,
+		USB_CTRL_USB_PM_xhc_soft_resetb_MASK,
+		USB_CTRL_USB_PM_USB_PWRDN_MASK,
+		0, /* USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ioc_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ipp_MASK */
+		USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK,
+	},
+	/* 7364a0 */
+	[BRCM_FAMILY_7364A0] = {
+		USB_CTRL_SETUP_scb1_en_MASK,
+		USB_CTRL_SETUP_scb2_en_MASK,
+		USB_CTRL_SETUP_ss_ehci64bit_en_MASK,
+		0, /* USB_CTRL_SETUP_strap_ipp_sel_MASK */
+		USB_CTRL_SETUP_OC3_DISABLE_MASK,
+		USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK,
+		USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK,
+		0, /* USB_CTRL_USB_PM_bdc_soft_resetb_MASK */
+		USB_CTRL_USB_PM_xhc_soft_resetb_var_MASK,
+		0, /* USB_CTRL_USB_PM_USB_PWRDN_MASK */
+		0, /* USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ioc_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ipp_MASK */
+		0, /* USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK */
+	},
+	/* 7366c0 */
+	[BRCM_FAMILY_7366C0] = {
+		USB_CTRL_SETUP_scb1_en_MASK,
+		USB_CTRL_SETUP_scb2_en_MASK,
+		USB_CTRL_SETUP_ss_ehci64bit_en_MASK,
+		0, /* USB_CTRL_SETUP_strap_ipp_sel_MASK */
+		USB_CTRL_SETUP_OC3_DISABLE_MASK,
+		0, /* USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK */
+		USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK,
+		0, /* USB_CTRL_USB_PM_bdc_soft_resetb_MASK */
+		USB_CTRL_USB_PM_xhc_soft_resetb_var_MASK,
+		USB_CTRL_USB_PM_USB_PWRDN_MASK,
+		0, /* USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ioc_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ipp_MASK */
+		0, /* USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK */
+	},
+	/* 74371A0 */
+	[BRCM_FAMILY_74371A0] = {
+		USB_CTRL_SETUP_scb1_en_MASK,
+		USB_CTRL_SETUP_scb2_en_MASK,
+		USB_CTRL_SETUP_ss_ehci64bit_en_var_MASK,
+		0, /* USB_CTRL_SETUP_strap_ipp_sel_MASK */
+		0, /* USB_CTRL_SETUP_OC3_DISABLE_MASK */
+		USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK,
+		0, /* USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK */
+		0, /* USB_CTRL_USB_PM_bdc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB_PM_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB_PM_USB_PWRDN_MASK */
+		USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK,
+		USB_CTRL_USB30_CTL1_usb3_ioc_MASK,
+		USB_CTRL_USB30_CTL1_usb3_ipp_MASK,
+		0, /* USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK */
+	},
+	/* 7439B0 */
+	[BRCM_FAMILY_7439B0] = {
+		USB_CTRL_SETUP_scb1_en_MASK,
+		USB_CTRL_SETUP_scb2_en_MASK,
+		USB_CTRL_SETUP_ss_ehci64bit_en_MASK,
+		USB_CTRL_SETUP_strap_ipp_sel_MASK,
+		USB_CTRL_SETUP_OC3_DISABLE_MASK,
+		0, /* USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK */
+		0, /* USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK */
+		USB_CTRL_USB_PM_bdc_soft_resetb_MASK,
+		USB_CTRL_USB_PM_xhc_soft_resetb_MASK,
+		USB_CTRL_USB_PM_USB_PWRDN_MASK,
+		0, /* USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ioc_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ipp_MASK */
+		USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK,
+	},
+	/* 7445d0 */
+	[BRCM_FAMILY_7445D0] = {
+		USB_CTRL_SETUP_scb1_en_MASK,
+		USB_CTRL_SETUP_scb2_en_MASK,
+		USB_CTRL_SETUP_ss_ehci64bit_en_var_MASK,
+		0, /* USB_CTRL_SETUP_strap_ipp_sel_MASK */
+		USB_CTRL_SETUP_OC3_DISABLE_MASK,
+		USB_CTRL_PLL_CTL_PLL_IDDQ_PWRDN_MASK,
+		0, /* USB_CTRL_EBRIDGE_ESTOP_SCB_REQ_MASK */
+		0, /* USB_CTRL_USB_PM_bdc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB_PM_xhc_soft_resetb_MASK */
+		0, /* USB_CTRL_USB_PM_USB_PWRDN_MASK */
+		USB_CTRL_USB30_CTL1_xhc_soft_resetb_MASK,
+		0, /* USB_CTRL_USB30_CTL1_usb3_ioc_MASK */
+		0, /* USB_CTRL_USB30_CTL1_usb3_ipp_MASK */
+		0, /* USB_CTRL_USB_DEVICE_CTL1_port_mode_MASK */
+	},
+};
+
+static inline uint32_t brcmusb_readl(void __iomem *addr)
+{
+	/*
+	 * MIPS endianness is configured by boot strap, which also reverses all
+	 * bus endianness (i.e., big-endian CPU + big endian bus ==> native
+	 * endian I/O).
+	 *
+	 * Other architectures (e.g., ARM) either do not support big endian, or
+	 * else leave I/O in little endian mode.
+	 */
+	if (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(__BIG_ENDIAN))
+		return __raw_readl(addr);
+	else
+		return readl_relaxed(addr);
+}
+
+static inline void brcmusb_writel(uint32_t val, void __iomem *addr)
+{
+	/* See brcmnand_readl() comments */
+	if (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(__BIG_ENDIAN))
+		__raw_writel(val, addr);
+	else
+		writel_relaxed(val, addr);
+}
+
+static inline void usb_ctrl_unset(void __iomem *reg, uint32_t mask)
+{
+	brcmusb_writel(brcmusb_readl(reg) & ~(mask), reg);
+};
+
+static inline void usb_ctrl_set(void __iomem *reg, uint32_t mask)
+{
+	brcmusb_writel(brcmusb_readl(reg) | (mask), reg);
+};
+
+static inline void usb_ctrl_unset_family(void __iomem *reg,	uint32_t field)
+{
+	uint32_t mask;
+
+	mask = usb_reg_bits_map[field];
+	usb_ctrl_unset(reg, mask);
+};
+
+static inline void usb_ctrl_set_family(void __iomem *reg, uint32_t field)
+{
+	uint32_t mask;
+
+	mask = usb_reg_bits_map[field];
+	usb_ctrl_set(reg, mask);
+};
+
+
+static uint32_t usb_mdio_read(void __iomem *ctrl_base, uint32_t reg, int mode)
+{
+	uint32_t data;
+
+	data = (reg << 16) | mode;
+	brcmusb_writel(data, USB_CTRL_REG(ctrl_base, MDIO));
+	data |= (1 << 24);
+	brcmusb_writel(data, USB_CTRL_REG(ctrl_base, MDIO));
+	data &= ~(1 << 24);
+	udelay(10);
+	brcmusb_writel(data, USB_CTRL_REG(ctrl_base, MDIO));
+	udelay(10);
+
+	return brcmusb_readl(USB_CTRL_REG(ctrl_base, MDIO2)) & 0xffff;
+}
+
+static void usb_mdio_write(void __iomem *ctrl_base, uint32_t reg,
+			uint32_t val, int mode)
+{
+	uint32_t data;
+
+	data = (reg << 16) | val | mode;
+	brcmusb_writel(data, USB_CTRL_REG(ctrl_base, MDIO));
+	data |= (1 << 25);
+	brcmusb_writel(data, USB_CTRL_REG(ctrl_base, MDIO));
+	data &= ~(1 << 25);
+	udelay(10);
+	brcmusb_writel(data, USB_CTRL_REG(ctrl_base, MDIO));
+}
+
+
+static void usb_phy_ldo_fix(void __iomem *ctrl_base)
+{
+	/* first disable FSM but also leave it that way */
+	/* to allow normal suspend/resume */
+	USB_CTRL_UNSET(ctrl_base, UTMI_CTL_1, POWER_UP_FSM_EN);
+	USB_CTRL_UNSET(ctrl_base, UTMI_CTL_1, POWER_UP_FSM_EN_P1);
+
+	/* reset USB 2.0 PLL */
+	USB_CTRL_UNSET(ctrl_base, PLL_CTL, PLL_RESETB);
+	msleep(1);
+	USB_CTRL_SET(ctrl_base, PLL_CTL, PLL_RESETB);
+	msleep(10);
+
+}
+
+
+static void usb2_eye_fix(void __iomem *ctrl_base)
+{
+	/* Increase USB 2.0 TX level to meet spec requirement */
+	usb_mdio_write(ctrl_base, 0x1f, 0x80a0, MDIO_USB2);
+	usb_mdio_write(ctrl_base, 0x0a, 0xc6a0, MDIO_USB2);
+}
+
+
+static void usb3_pll_fix(void __iomem *ctrl_base)
+{
+	/* Set correct window for PLL lock detect */
+	usb_mdio_write(ctrl_base, 0x1f, 0x8000, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x07, 0x1503, MDIO_USB3);
+}
+
+
+static void usb3_enable_pipe_reset(void __iomem *ctrl_base)
+{
+	uint32_t val;
+
+	/* Re-enable USB 3.0 pipe reset */
+	usb_mdio_write(ctrl_base, 0x1f, 0x8000, MDIO_USB3);
+	val = usb_mdio_read(ctrl_base, 0x0f, MDIO_USB3) | 0x200;
+	usb_mdio_write(ctrl_base, 0x0f, val, MDIO_USB3);
+}
+
+
+static void usb3_enable_sigdet(void __iomem *ctrl_base)
+{
+	uint32_t val, ofs;
+	int ii;
+
+	ofs = 0;
+	for (ii = 0; ii < 2; ++ii) {
+		/* Set correct default for sigdet */
+		usb_mdio_write(ctrl_base, 0x1f, (0x8080 + ofs), MDIO_USB3);
+		val = usb_mdio_read(ctrl_base, 0x05, MDIO_USB3);
+		val = (val & ~0x800f) | 0x800d;
+		usb_mdio_write(ctrl_base, 0x05, val, MDIO_USB3);
+		ofs = 0x1000;
+	}
+}
+
+
+static void usb3_enable_skip_align(void __iomem *ctrl_base)
+{
+	uint32_t val, ofs;
+	int ii;
+
+	ofs = 0;
+	for (ii = 0; ii < 2; ++ii) {
+		/* Set correct default for SKIP align */
+		usb_mdio_write(ctrl_base, 0x1f, (0x8060 + ofs), MDIO_USB3);
+		val = usb_mdio_read(ctrl_base, 0x01, MDIO_USB3) | 0x200;
+		usb_mdio_write(ctrl_base, 0x01, val, MDIO_USB3);
+		ofs = 0x1000;
+	}
+}
+
+
+static void usb3_pll_54Mhz(void __iomem *ctrl_base)
+{
+	uint32_t ofs;
+	int ii;
+
+	if (my_family != BRCM_FAMILY_7271A0)
+		return;
+	/*
+	 * On the 7271a0 and 7268a0, the reference clock for the
+	 * 3.0 PLL has been changed from 50MHz to 54MHz so the
+	 * PLL needs to be reprogramed. Later chips will have
+	 * the PLL programmed correctly on power-up.
+	 * See SWLINUX-4006.
+	 */
+
+	/* set USB 3.0 PLL to accept 54Mhz reference clock */
+	USB_CTRL_UNSET(ctrl_base, USB30_CTL1, phy3_pll_seq_start);
+
+	usb_mdio_write(ctrl_base, 0x1f, 0x8000, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x10, 0x5784, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x11, 0x01d0, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x12, 0x1DE8, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x13, 0xAA80, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x14, 0x8826, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x15, 0x0044, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x16, 0x8000, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x17, 0x0851, MDIO_USB3);
+	usb_mdio_write(ctrl_base, 0x18, 0x0000, MDIO_USB3);
+
+	/* both ports */
+	ofs = 0;
+	for (ii = 0; ii < 2; ++ii) {
+		usb_mdio_write(ctrl_base, 0x1f, (0x8040 + ofs), MDIO_USB3);
+		usb_mdio_write(ctrl_base, 0x03, 0x0090, MDIO_USB3);
+		usb_mdio_write(ctrl_base, 0x04, 0x0134, MDIO_USB3);
+		usb_mdio_write(ctrl_base, 0x1f, (0x8020 + ofs), MDIO_USB3);
+		usb_mdio_write(ctrl_base, 0x01, 0x00e2, MDIO_USB3);
+		ofs = 0x1000;
+	}
+
+	/* restart PLL sequence */
+	USB_CTRL_SET(ctrl_base, USB30_CTL1, phy3_pll_seq_start);
+	msleep(1);
+}
+
+
+static void usb3_ssc_enable(void __iomem *ctrl_base)
+{
+	uint32_t val;
+
+	/* Enable USB 3.0 TX spread spectrum */
+	usb_mdio_write(ctrl_base, 0x1f, 0x8040, MDIO_USB3);
+	val = usb_mdio_read(ctrl_base, 0x01, MDIO_USB3) | 0xf;
+	usb_mdio_write(ctrl_base, 0x01, val, MDIO_USB3);
+
+	/* Currently, USB 3.0 SSC is enabled via port 0 MDIO registers,
+	 * which should have been adequate. However, due to a bug in the
+	 * USB 3.0 PHY, it must be enabled via both ports (HWUSB3DVT-26).
+	 */
+	usb_mdio_write(ctrl_base, 0x1f, 0x9040, MDIO_USB3);
+	val = usb_mdio_read(ctrl_base, 0x01, MDIO_USB3) | 0xf;
+	usb_mdio_write(ctrl_base, 0x01, val, MDIO_USB3);
+}
+
+
+static void usb3_phy_workarounds(void __iomem *ctrl_base)
+{
+	usb3_pll_fix(ctrl_base);
+	usb3_pll_54Mhz(ctrl_base);
+	usb3_ssc_enable(ctrl_base);
+	usb3_enable_pipe_reset(ctrl_base);
+	usb3_enable_sigdet(ctrl_base);
+	usb3_enable_skip_align(ctrl_base);
+}
+
+
+static void memc_fix(struct brcm_usb_common_init_params *params)
+{
+	void __iomem *ctrl_base = params->ctrl_regs;
+	uint32_t prid;
+
+	if (my_family != BRCM_FAMILY_7445D0)
+		return;
+	/*
+	 * This is a workaround for HW7445-1869 where a DMA write ends up
+	 * doing a read pre-fetch after the end of the DMA buffer. This
+	 * causes a problem when the DMA buffer is at the end of physical
+	 * memory, causing the pre-fetch read to access non-existent memory,
+	 * and the chip bondout has MEMC2 disabled. When the pre-fetch read
+	 * tries to use the disabled MEMC2, it hangs the bus. The workaround
+	 * is to disable MEMC2 access in the usb controller which avoids
+	 * the hang.
+	 */
+
+	prid = params->product_id & 0xfffff000;
+	switch (prid) {
+	case 0x72520000:
+	case 0x74480000:
+	case 0x74490000:
+	case 0x07252000:
+	case 0x07448000:
+	case 0x07449000:
+		USB_CTRL_UNSET_FAMILY(ctrl_base, SETUP, scb2_en);
+	}
+}
+
+static void usb3_otp_fix(struct brcm_usb_common_init_params *params)
+{
+	void __iomem *xhci_ec_base = params->xhci_ec_regs;
+	uint32_t val;
+
+	if ((params->family_id != 0x74371000) || (xhci_ec_base == 0))
+		return;
+	brcmusb_writel(0xa20c, USB_XHCI_EC_REG(xhci_ec_base, IRAADR));
+	val = brcmusb_readl(USB_XHCI_EC_REG(xhci_ec_base, IRADAT));
+
+	/* set cfg_pick_ss_lock */
+	val |= (1 << 27);
+	brcmusb_writel(val, USB_XHCI_EC_REG(xhci_ec_base, IRADAT));
+
+	/* Reset USB 3.0 PHY for workaround to take effect */
+	USB_CTRL_UNSET(params->ctrl_regs, USB30_CTL1, phy3_resetb);
+	USB_CTRL_SET(params->ctrl_regs,	USB30_CTL1, phy3_resetb);
+}
+
+
+static void xhci_soft_reset(void __iomem *ctrl, int on_off)
+{
+	/* Assert reset */
+	if (on_off) {
+		if (USB_CTRL_MASK_FAMILY(USB_PM, xhc_soft_resetb))
+			USB_CTRL_UNSET_FAMILY(ctrl, USB_PM, xhc_soft_resetb);
+		else
+			USB_CTRL_UNSET_FAMILY(ctrl,
+					USB30_CTL1, xhc_soft_resetb);
+	}
+	/* De-assert reset */
+	else {
+		if (USB_CTRL_MASK_FAMILY(USB_PM, xhc_soft_resetb))
+			USB_CTRL_SET_FAMILY(ctrl, USB_PM, xhc_soft_resetb);
+		else
+			USB_CTRL_SET_FAMILY(ctrl, USB30_CTL1, xhc_soft_resetb);
+	}
+}
+
+static enum brcm_family_type get_family_type(
+	struct brcm_usb_common_init_params *params)
+{
+	unsigned int x;
+
+	for (x = 0;
+	     x < (sizeof(id_to_type_table) / sizeof(struct id_to_type));
+	     x++)
+		/* ignore the minor rev */
+		if ((params->family_id & 0xfffffff0) ==
+			id_to_type_table[x].id) {
+			return id_to_type_table[x].type;
+		}
+	return BRCM_FAMILY_DEFAULT;
+}
+
+void brcm_usb_common_init(struct brcm_usb_common_init_params *params)
+{
+	uint32_t reg;
+	void __iomem *ctrl = params->ctrl_regs;
+	int change_ipp = 0;
+
+	my_family = get_family_type(params);
+	usb_reg_bits_map = &usb_reg_bits_map_table[my_family][0];
+	xhci_soft_reset(ctrl, 1);
+
+	if (BRCM_ID(params->family_id) == 0x7366) {
+		/*
+		 * The PHY3_SOFT_RESETB bits default to the wrong state.
+		 */
+		USB_CTRL_SET(ctrl, USB30_PCTL, PHY3_SOFT_RESETB);
+		USB_CTRL_SET(ctrl, USB30_PCTL, PHY3_SOFT_RESETB_P1);
+	}
+	if (my_family == BRCM_FAMILY_7366C0)
+		/*
+		 * Don't enable this so the memory controller doesn't read
+		 * into memory holes. NOTE: This bit is low true on 7366C0.
+		 */
+		USB_CTRL_SET_FAMILY(ctrl, EBRIDGE, ESTOP_SCB_REQ);
+
+	/* Take USB out of power down */
+	if (USB_CTRL_MASK_FAMILY(PLL_CTL, PLL_IDDQ_PWRDN)) {
+		USB_CTRL_UNSET_FAMILY(ctrl, PLL_CTL, PLL_IDDQ_PWRDN);
+		/* 1 millisecond - for USB clocks to settle down */
+		msleep(1);
+	}
+
+	/* 3390a0 & 7439b0 so far. */
+	if (USB_CTRL_MASK_FAMILY(USB_PM, USB_PWRDN)) {
+		USB_CTRL_UNSET_FAMILY(ctrl, USB_PM, USB_PWRDN);
+		/* 1 millisecond - for USB clocks to settle down */
+		msleep(1);
+	}
+
+	/* Starting with the 7445d0, there are no longer separate 3.0
+	 * versions of IOC and IPP.
+	 */
+	if (USB_CTRL_MASK_FAMILY(USB30_CTL1, usb3_ioc)) {
+		if (params->ioc)
+			USB_CTRL_SET_FAMILY(ctrl, USB30_CTL1, usb3_ioc);
+		if (params->ipp == 1)
+			USB_CTRL_SET_FAMILY(ctrl, USB30_CTL1, usb3_ipp);
+	}
+
+	if ((my_family != BRCM_FAMILY_74371A0) &&
+		(BRCM_ID(params->family_id) != 0x7364))
+		/*
+		 * HW7439-637: 7439a0 and its derivatives do not have large
+		 * enough descriptor storage for this.
+		 */
+		USB_CTRL_SET_FAMILY(ctrl, SETUP, ss_ehci64bit_en);
+
+	/*
+	 * Kick start USB3 PHY
+	 * Make sure it's low to insure a rising edge.
+	 */
+	USB_CTRL_UNSET(ctrl, USB30_CTL1, phy3_pll_seq_start);
+	USB_CTRL_SET(ctrl, USB30_CTL1, phy3_pll_seq_start);
+
+	/* Block auto PLL suspend by USB2 PHY */
+	USB_CTRL_SET(ctrl, PLL_CTL, PLL_SUSPEND_EN);
+
+	usb_phy_ldo_fix(ctrl);
+	usb2_eye_fix(ctrl);
+	if (params->has_xhci)
+		usb3_phy_workarounds(ctrl);
+
+	/* Setup the endian bits */
+	reg = brcmusb_readl(USB_CTRL_REG(ctrl, SETUP));
+	reg &= ~USB_CTRL_SETUP_CONDITIONAL_BITS;
+	reg |= ENDIAN_SETTINGS;
+
+	if (my_family == BRCM_FAMILY_7364A0)
+		/* Suppress overcurrent indication from USB30 ports for A0 */
+		reg |= USB_CTRL_MASK_FAMILY(SETUP, OC3_DISABLE);
+
+	if (USB_CTRL_MASK_FAMILY(SETUP, strap_ipp_sel))
+		if (params->ipp != 2)
+			/* override ipp strap pin (if it exits) */
+			reg &= ~(USB_CTRL_MASK_FAMILY(SETUP, strap_ipp_sel));
+
+	/*
+	 * Make sure the the second and third memory controller
+	 * interfaces are enabled.
+	 */
+	if (USB_CTRL_MASK_FAMILY(SETUP, scb1_en))
+		reg |= USB_CTRL_MASK_FAMILY(SETUP, scb1_en);
+	if (USB_CTRL_MASK_FAMILY(SETUP, scb2_en))
+		reg |= USB_CTRL_MASK_FAMILY(SETUP, scb2_en);
+
+	/* Override the default OC and PP polarity */
+	if (params->ioc)
+		reg |= USB_CTRL_MASK(SETUP, IOC);
+	if ((params->ipp == 1) &&
+		((reg & USB_CTRL_MASK(SETUP, IPP)) == 0)) {
+		change_ipp = 1;
+		reg |= USB_CTRL_MASK(SETUP, IPP);
+	}
+	brcmusb_writel(reg, USB_CTRL_REG(ctrl, SETUP));
+
+	/*
+	 * If we're changing IPP, make sure power is off long enough
+	 * to turn off any connected devices.
+	 */
+	if (change_ipp)
+		msleep(50);
+	memc_fix(params);
+	if (params->has_xhci) {
+		xhci_soft_reset(ctrl, 0);
+		usb3_otp_fix(params);
+	}
+	if (USB_CTRL_MASK_FAMILY(USB_DEVICE_CTL1, port_mode)) {
+		reg = brcmusb_readl(USB_CTRL_REG(ctrl, USB_DEVICE_CTL1));
+		reg &= ~USB_CTRL_MASK_FAMILY(USB_DEVICE_CTL1, port_mode);
+		reg |= params->device_mode;
+		brcmusb_writel(reg, USB_CTRL_REG(ctrl, USB_DEVICE_CTL1));
+	}
+	if (USB_CTRL_MASK_FAMILY(USB_PM, bdc_soft_resetb)) {
+		switch (params->device_mode) {
+		case USB_CTLR_DEVICE_OFF:
+			USB_CTRL_UNSET_FAMILY(ctrl, USB_PM, bdc_soft_resetb);
+			break;
+		case USB_CTLR_DEVICE_ON:
+		case USB_CTLR_DEVICE_DUAL:
+			USB_CTRL_SET_FAMILY(ctrl, USB_PM, bdc_soft_resetb);
+		break;
+		}
+	}
+}
diff --git a/drivers/phy/phy-brcm-usb-init.h b/drivers/phy/phy-brcm-usb-init.h
new file mode 100644
index 000000000000..e49918c985ab
--- /dev/null
+++ b/drivers/phy/phy-brcm-usb-init.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014-2016 Broadcom
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _PHY_BRCM_USB_INIT_H
+#define _PHY_BRCM_USB_INIT_H
+
+#define USB_CTLR_DEVICE_OFF 0
+#define USB_CTLR_DEVICE_ON 1
+#define USB_CTLR_DEVICE_DUAL 2
+
+struct  brcm_usb_common_init_params {
+	void __iomem *ctrl_regs;
+	void __iomem *xhci_ec_regs;
+	int ioc;
+	int ipp;
+	int has_xhci;
+	int device_mode;
+	uint32_t family_id;
+	uint32_t product_id;
+};
+
+void brcm_usb_common_init(struct  brcm_usb_common_init_params *params);
+
+#endif /* _PHY_BRCM_USB_INIT_H */
diff --git a/drivers/phy/phy-brcm-usb.c b/drivers/phy/phy-brcm-usb.c
new file mode 100644
index 000000000000..5edca1cc75c7
--- /dev/null
+++ b/drivers/phy/phy-brcm-usb.c
@@ -0,0 +1,206 @@
+/*
+ * phy-brcm-usb.c - Broadcom USB Phy Driver
+ *
+ * Copyright (C) 2015 Broadcom Corporation
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include "phy-brcm-usb-init.h"
+#include <linux/soc/brcmstb/brcmstb.h>
+
+
+enum brcm_usb_phy_id {
+	BRCM_USB_PHY_2_0,
+	BRCM_USB_PHY_3_0,
+	BRCM_USB_PHY_ID_MAX
+};
+
+struct brcm_usb_phy_data {
+	struct  brcm_usb_common_init_params ini;
+	void __iomem		*ctrl_regs;
+	void __iomem		*xhci_ec_regs;
+	int			ioc;
+	int			ipp;
+	int			has_xhci;
+	int			device_mode;
+	struct clk		*usb_clk;
+	int			num_phys;
+	struct brcm_usb_phy {
+		struct phy *phy;
+		unsigned int index;
+	} phys[BRCM_USB_PHY_ID_MAX];
+};
+
+#define to_brcm_usb_phy_data(phy) \
+	container_of((phy), struct brcm_usb_phy_data, phys[(phy)->index])
+
+static struct phy_ops brcm_usb_phy_ops = {
+	.owner		= THIS_MODULE,
+};
+
+static struct phy *brcm_usb_phy_xlate(struct device *dev,
+				struct of_phandle_args *args)
+{
+	struct brcm_usb_phy_data *data = dev_get_drvdata(dev);
+
+	if (args->args[0] >= data->num_phys)
+		return ERR_PTR(-ENODEV);
+
+	return data->phys[args->args[0]].phy;
+}
+
+static int brcm_usb_phy_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	struct brcm_usb_phy_data *priv;
+	struct phy *gphy;
+	struct phy_provider *phy_provider;
+	struct device_node *dn = pdev->dev.of_node;
+	const u32 *prop;
+	int i;
+	int err;
+	const char *device_mode;
+	char err_msg_ioremap[] = "can't map register space\n";
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, priv);
+
+	priv->ini.family_id = brcmstb_get_family_id();
+	priv->ini.product_id = brcmstb_get_product_id();
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "can't get USB_CTRL base address\n");
+		return -EINVAL;
+	}
+	priv->ini.ctrl_regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->ini.ctrl_regs)) {
+		dev_err(dev, err_msg_ioremap);
+		return -EINVAL;
+	}
+
+	/* The XHCI EC registers are optional */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res != NULL) {
+		priv->ini.xhci_ec_regs =
+			devm_ioremap_resource(&pdev->dev, res);
+		if (IS_ERR(priv->ini.xhci_ec_regs)) {
+			dev_err(&pdev->dev, err_msg_ioremap);
+			return -EINVAL;
+		}
+	}
+
+	of_property_read_u32(dn, "ipp", &priv->ini.ipp);
+	of_property_read_u32(dn, "ioc", &priv->ini.ioc);
+
+	priv->ini.device_mode = USB_CTLR_DEVICE_OFF;
+	err = of_property_read_string(dn, "device", &device_mode);
+	if (err == 0) {
+		if (strcmp(device_mode, "on") == 0)
+			priv->ini.device_mode = USB_CTLR_DEVICE_ON;
+		if (strcmp(device_mode, "dual") == 0)
+			priv->ini.device_mode = USB_CTLR_DEVICE_DUAL;
+	}
+
+	prop = of_get_property(dn, "has_xhci", NULL);
+	if (prop) {
+		priv->ini.has_xhci = 1;
+		priv->num_phys = 2;
+	} else {
+		priv->num_phys = 1;
+	}
+
+	for (i = 0; i < priv->num_phys; i++) {
+		gphy = devm_phy_create(dev, NULL, &brcm_usb_phy_ops);
+		if (IS_ERR(gphy)) {
+			dev_err(dev, "failed to create PHY %d\n", i);
+			return PTR_ERR(gphy);
+		}
+		priv->phys[i].phy = gphy;
+		priv->phys[i].index = i;
+		phy_set_drvdata(gphy, &priv->phys[i]);
+	}
+	phy_provider = devm_of_phy_provider_register(dev,
+			brcm_usb_phy_xlate);
+	if (IS_ERR(phy_provider))
+		return PTR_ERR(phy_provider);
+
+	priv->usb_clk = of_clk_get_by_name(dn, "sw_usb");
+	if (IS_ERR(priv->usb_clk)) {
+		dev_err(&pdev->dev, "Clock not found in Device Tree\n");
+		priv->usb_clk = NULL;
+	}
+	err = clk_prepare_enable(priv->usb_clk);
+	if (err)
+		return err;
+
+	brcm_usb_common_init(&priv->ini);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int brcm_usb_phy_suspend(struct device *dev)
+{
+	struct brcm_usb_phy_data *priv = dev_get_drvdata(dev);
+
+	clk_disable(priv->usb_clk);
+	return 0;
+}
+
+static int brcm_usb_phy_resume(struct device *dev)
+{
+	struct brcm_usb_phy_data *priv = dev_get_drvdata(dev);
+
+	clk_enable(priv->usb_clk);
+	brcm_usb_common_init(&priv->ini);
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(brcm_usb_phy_pm_ops, brcm_usb_phy_suspend,
+		brcm_usb_phy_resume);
+
+static const struct of_device_id brcm_usb_dt_ids[] = {
+	{ .compatible = "brcm,brcmstb-usb-phy" },
+	{ /* sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, brcm_usb_dt_ids);
+
+static struct platform_driver brcm_usb_driver = {
+	.probe		= brcm_usb_phy_probe,
+	.driver		= {
+		.name	= "brcmstb-usb-phy",
+		.owner	= THIS_MODULE,
+		.pm = &brcm_usb_phy_pm_ops,
+		.of_match_table = brcm_usb_dt_ids,
+	},
+};
+
+module_platform_driver(brcm_usb_driver);
+
+MODULE_ALIAS("platform:brcmstb-usb-phy");
+MODULE_AUTHOR("Al Cooper <alcooperx@gmail.com>");
+MODULE_DESCRIPTION("BRCM USB PHY driver for STB systems");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/soc/bcm/brcmstb/Makefile b/drivers/soc/bcm/brcmstb/Makefile
index 756c08335a75..8280ac04d186 100644
--- a/drivers/soc/bcm/brcmstb/Makefile
+++ b/drivers/soc/bcm/brcmstb/Makefile
@@ -1,4 +1,4 @@
 obj-$(CONFIG_BRCMSTB_PM)	+= pm/
 obj-$(CONFIG_BRCMSTB_SRPD)	+= srpd.o
 
-obj-y				+= common.o biuctrl.o cma_driver.o
+obj-y				+= common.o biuctrl.o bmem.o
diff --git a/drivers/soc/bcm/brcmstb/bmem.c b/drivers/soc/bcm/brcmstb/bmem.c
new file mode 100644
index 000000000000..c9f322216a91
--- /dev/null
+++ b/drivers/soc/bcm/brcmstb/bmem.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright © 2015-2016 Broadcom
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation (the "GPL").
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * A copy of the GPL is available at
+ * http://www.broadcom.com/licenses/GPLv2.php or from the Free Software
+ * Foundation at https://www.gnu.org/licenses/ .
+ */
+
+#include <linux/module.h>
+#include <linux/cma.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_reserved_mem.h>
+
+#define MAX_BMEM_REGIONS	8
+
+struct bmem_region {
+	struct device *dev;
+	phys_addr_t addr;
+	phys_addr_t size;
+	bool valid;
+};
+
+static struct bmem_region bmem_regions[MAX_BMEM_REGIONS];
+static unsigned int n_bmem_regions;
+
+struct device *brcmstb_bmem_get_device(int region_num)
+{
+	if (region_num >= n_bmem_regions)
+		return NULL;
+
+	return bmem_regions[region_num].dev;
+}
+EXPORT_SYMBOL(brcmstb_bmem_get_device);
+
+static int brcmstb_bmem_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	ret = of_reserved_mem_device_init(dev);
+	if (ret)
+		return ret;
+
+	bmem_regions[n_bmem_regions].dev = dev;
+	bmem_regions[n_bmem_regions].valid = true;
+	n_bmem_regions++;
+
+	return 0;
+}
+
+static const struct of_device_id brcmstb_bmem_of_match[] = {
+	{ .compatible = "brcm,bmem" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, brcmstb_bmem_of_match);
+
+static struct platform_driver brcmstb_bmem_driver = {
+	.driver		= {
+		.name	= "brcmstb-bmem",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(brcmstb_bmem_of_match),
+	},
+	.probe		= brcmstb_bmem_probe,
+};
+
+module_platform_driver(brcmstb_bmem_driver);
diff --git a/drivers/soc/bcm/brcmstb/cma_driver.c b/drivers/soc/bcm/brcmstb/cma_driver.c
deleted file mode 100644
index de6976cae76b..000000000000
--- a/drivers/soc/bcm/brcmstb/cma_driver.c
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- *  cma_driver.c - Broadcom STB platform CMA driver
- *
- *  Copyright © 2009 - 2015 Broadcom Corporation
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  A copy of the GPL is available at
- *  http://www.broadcom.com/licenses/GPLv2.php or from the Free Software
- *  Foundation at https://www.gnu.org/licenses/ .
- */
-
-#include <linux/module.h>
-#include <linux/cma.h>
-#include <linux/of.h>
-#include <linux/of_platform.h>
-#include <linux/of_reserved_mem.h>
-
-struct device *cma_dev[MAX_CMA_AREAS];
-
-struct device *brcmstb_cma_get_dev(int region_num)
-{
-	if (region_num >= ARRAY_SIZE(cma_dev))
-		return NULL;
-
-	return cma_dev[region_num];
-}
-EXPORT_SYMBOL(brcmstb_cma_get_dev);
-
-static int brcmstb_cma_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	int region_num;
-	int ret;
-
-	ret = of_property_read_u32(dev->of_node, "brcm,region-num",
-				   &region_num);
-	if (ret)
-		return ret;
-
-	ret = of_reserved_mem_device_init(dev);
-	if (ret)
-		return ret;
-
-	cma_dev[region_num] = dev;
-
-	return 0;
-}
-
-static const struct of_device_id brcmstb_cma_of_match[] = {
-	{ .compatible = "brcm,cma-plat-dev" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, brcmstb_cma_of_match);
-
-static struct platform_driver brcmstb_cma_driver = {
-	.driver		= {
-		.name	= "brcm-cma",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(brcmstb_cma_of_match),
-	},
-	.probe		= brcmstb_cma_probe,
-};
-
-module_platform_driver(brcmstb_cma_driver);
diff --git a/drivers/soc/bcm/brcmstb/common.c b/drivers/soc/bcm/brcmstb/common.c
index 94e7335553f4..454f4c2ddf06 100644
--- a/drivers/soc/bcm/brcmstb/common.c
+++ b/drivers/soc/bcm/brcmstb/common.c
@@ -40,6 +40,18 @@ bool soc_is_brcmstb(void)
 	return of_match_node(brcmstb_machine_match, root) != NULL;
 }
 
+u32 brcmstb_get_family_id(void)
+{
+	return family_id;
+}
+EXPORT_SYMBOL(brcmstb_get_family_id);
+
+u32 brcmstb_get_product_id(void)
+{
+	return product_id;
+}
+EXPORT_SYMBOL(brcmstb_get_product_id);
+
 static const struct of_device_id sun_top_ctrl_match[] = {
 	{ .compatible = "brcm,brcmstb-sun-top-ctrl", },
 	{ }
diff --git a/include/linux/clk-provider.h b/include/linux/clk-provider.h
index a428aec36ace..8aba9c7b48df 100644
--- a/include/linux/clk-provider.h
+++ b/include/linux/clk-provider.h
@@ -35,6 +35,7 @@
 #define CLK_IS_CRITICAL		BIT(11) /* do not gate, ever */
 /* parents need enable during gate/ungate, set rate and re-parent */
 #define CLK_OPS_PARENT_ENABLE	BIT(12)
+#define CLK_IS_SW		BIT(13) /* sw clk, multiple active parents */
 
 struct clk;
 struct clk_hw;
@@ -601,12 +602,18 @@ void clk_hw_unregister_fractional_divider(struct clk_hw *hw);
  * CLK_MULTIPLIER_ROUND_CLOSEST - Makes the best calculated divider to be
  *	rounded to the closest integer instead of the down one.
  */
+struct clk_mult_table {
+	unsigned int	val;
+	unsigned int	mult;
+};
+
 struct clk_multiplier {
 	struct clk_hw	hw;
 	void __iomem	*reg;
 	u8		shift;
 	u8		width;
 	u8		flags;
+	const struct clk_mult_table	*table;
 	spinlock_t	*lock;
 };
 
diff --git a/include/linux/soc/brcmstb/brcmstb.h b/include/linux/soc/brcmstb/brcmstb.h
index 337ce414e898..4bf5eddedd87 100644
--- a/include/linux/soc/brcmstb/brcmstb.h
+++ b/include/linux/soc/brcmstb/brcmstb.h
@@ -1,10 +1,20 @@
 #ifndef __BRCMSTB_SOC_H
 #define __BRCMSTB_SOC_H
 
+#define BRCM_ID(reg)	((u32)reg >> 28 ? (u32)reg >> 16 : (u32)reg >> 8)
+#define BRCM_REV(reg)	((u32)reg & 0xff)
+
 /*
  * Bus Interface Unit control register setup, must happen early during boot,
  * before SMP is brought up, called by machine entry point.
  */
 void brcmstb_biuctrl_init(void);
 
+/*
+* Helper functions for getting family or product id from the
+* SoC driver.
+*/
+u32 brcmstb_get_family_id(void);
+u32 brcmstb_get_product_id(void);
+
 #endif /* __BRCMSTB_SOC_H */
